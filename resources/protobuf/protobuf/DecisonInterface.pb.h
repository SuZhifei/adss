// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DecisonInterface.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_DecisonInterface_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_DecisonInterface_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_DecisonInterface_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_DecisonInterface_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_DecisonInterface_2eproto;
namespace IBUS {
class ControlPointInf;
class ControlPointInfDefaultTypeInternal;
extern ControlPointInfDefaultTypeInternal _ControlPointInf_default_instance_;
class DDTDecision;
class DDTDecisionDefaultTypeInternal;
extern DDTDecisionDefaultTypeInternal _DDTDecision_default_instance_;
class DDTDecision_ObjectDecision;
class DDTDecision_ObjectDecisionDefaultTypeInternal;
extern DDTDecision_ObjectDecisionDefaultTypeInternal _DDTDecision_ObjectDecision_default_instance_;
class DebugPointInf;
class DebugPointInfDefaultTypeInternal;
extern DebugPointInfDefaultTypeInternal _DebugPointInf_default_instance_;
class DecisionPlanMsg;
class DecisionPlanMsgDefaultTypeInternal;
extern DecisionPlanMsgDefaultTypeInternal _DecisionPlanMsg_default_instance_;
class DecisionService;
class DecisionServiceDefaultTypeInternal;
extern DecisionServiceDefaultTypeInternal _DecisionService_default_instance_;
class MissionDecision;
class MissionDecisionDefaultTypeInternal;
extern MissionDecisionDefaultTypeInternal _MissionDecision_default_instance_;
class NavigationService;
class NavigationServiceDefaultTypeInternal;
extern NavigationServiceDefaultTypeInternal _NavigationService_default_instance_;
class PathBoundPoint;
class PathBoundPointDefaultTypeInternal;
extern PathBoundPointDefaultTypeInternal _PathBoundPoint_default_instance_;
class Recommendation;
class RecommendationDefaultTypeInternal;
extern RecommendationDefaultTypeInternal _Recommendation_default_instance_;
class RefLinePoint;
class RefLinePointDefaultTypeInternal;
extern RefLinePointDefaultTypeInternal _RefLinePoint_default_instance_;
class TrajectoryPlanningService;
class TrajectoryPlanningServiceDefaultTypeInternal;
extern TrajectoryPlanningServiceDefaultTypeInternal _TrajectoryPlanningService_default_instance_;
class TrajectoryPoint;
class TrajectoryPointDefaultTypeInternal;
extern TrajectoryPointDefaultTypeInternal _TrajectoryPoint_default_instance_;
}  // namespace IBUS
PROTOBUF_NAMESPACE_OPEN
template<> ::IBUS::ControlPointInf* Arena::CreateMaybeMessage<::IBUS::ControlPointInf>(Arena*);
template<> ::IBUS::DDTDecision* Arena::CreateMaybeMessage<::IBUS::DDTDecision>(Arena*);
template<> ::IBUS::DDTDecision_ObjectDecision* Arena::CreateMaybeMessage<::IBUS::DDTDecision_ObjectDecision>(Arena*);
template<> ::IBUS::DebugPointInf* Arena::CreateMaybeMessage<::IBUS::DebugPointInf>(Arena*);
template<> ::IBUS::DecisionPlanMsg* Arena::CreateMaybeMessage<::IBUS::DecisionPlanMsg>(Arena*);
template<> ::IBUS::DecisionService* Arena::CreateMaybeMessage<::IBUS::DecisionService>(Arena*);
template<> ::IBUS::MissionDecision* Arena::CreateMaybeMessage<::IBUS::MissionDecision>(Arena*);
template<> ::IBUS::NavigationService* Arena::CreateMaybeMessage<::IBUS::NavigationService>(Arena*);
template<> ::IBUS::PathBoundPoint* Arena::CreateMaybeMessage<::IBUS::PathBoundPoint>(Arena*);
template<> ::IBUS::Recommendation* Arena::CreateMaybeMessage<::IBUS::Recommendation>(Arena*);
template<> ::IBUS::RefLinePoint* Arena::CreateMaybeMessage<::IBUS::RefLinePoint>(Arena*);
template<> ::IBUS::TrajectoryPlanningService* Arena::CreateMaybeMessage<::IBUS::TrajectoryPlanningService>(Arena*);
template<> ::IBUS::TrajectoryPoint* Arena::CreateMaybeMessage<::IBUS::TrajectoryPoint>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace IBUS {

enum MissionDecision_MissionType : int {
  MissionDecision_MissionType_END_POINT = 0,
  MissionDecision_MissionType_CRUISE = 1,
  MissionDecision_MissionType_STOP = 2,
  MissionDecision_MissionType_LANE_CHANGE_LEFT = 3,
  MissionDecision_MissionType_LANE_CHANGE_RIGHT = 4,
  MissionDecision_MissionType_PARKING = 5,
  MissionDecision_MissionType_U_TURN = 6,
  MissionDecision_MissionType_TURN_LEFT = 7,
  MissionDecision_MissionType_TURN_RIGHT = 8,
  MissionDecision_MissionType_WORKING_L = 9,
  MissionDecision_MissionType_WORKING_R = 10,
  MissionDecision_MissionType_WORKING_ALL = 11,
  MissionDecision_MissionType_LANE_BORROW_L = 12,
  MissionDecision_MissionType_LANE_BORROW_R = 13,
  MissionDecision_MissionType_MissionDecision_MissionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MissionDecision_MissionType_MissionDecision_MissionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MissionDecision_MissionType_IsValid(int value);
constexpr MissionDecision_MissionType MissionDecision_MissionType_MissionType_MIN = MissionDecision_MissionType_END_POINT;
constexpr MissionDecision_MissionType MissionDecision_MissionType_MissionType_MAX = MissionDecision_MissionType_LANE_BORROW_R;
constexpr int MissionDecision_MissionType_MissionType_ARRAYSIZE = MissionDecision_MissionType_MissionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MissionDecision_MissionType_descriptor();
template<typename T>
inline const std::string& MissionDecision_MissionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MissionDecision_MissionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MissionDecision_MissionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MissionDecision_MissionType_descriptor(), enum_t_value);
}
inline bool MissionDecision_MissionType_Parse(
    const std::string& name, MissionDecision_MissionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MissionDecision_MissionType>(
    MissionDecision_MissionType_descriptor(), name, value);
}
enum MissionDecision_StatusMDecision : int {
  MissionDecision_StatusMDecision_NORMAL = 0,
  MissionDecision_StatusMDecision_EMERGENCY = 1,
  MissionDecision_StatusMDecision_COLLSION_WARNING = 2,
  MissionDecision_StatusMDecision_FAILURE_DECTECTED = 3,
  MissionDecision_StatusMDecision_MissionDecision_StatusMDecision_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MissionDecision_StatusMDecision_MissionDecision_StatusMDecision_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MissionDecision_StatusMDecision_IsValid(int value);
constexpr MissionDecision_StatusMDecision MissionDecision_StatusMDecision_StatusMDecision_MIN = MissionDecision_StatusMDecision_NORMAL;
constexpr MissionDecision_StatusMDecision MissionDecision_StatusMDecision_StatusMDecision_MAX = MissionDecision_StatusMDecision_FAILURE_DECTECTED;
constexpr int MissionDecision_StatusMDecision_StatusMDecision_ARRAYSIZE = MissionDecision_StatusMDecision_StatusMDecision_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MissionDecision_StatusMDecision_descriptor();
template<typename T>
inline const std::string& MissionDecision_StatusMDecision_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MissionDecision_StatusMDecision>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MissionDecision_StatusMDecision_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MissionDecision_StatusMDecision_descriptor(), enum_t_value);
}
inline bool MissionDecision_StatusMDecision_Parse(
    const std::string& name, MissionDecision_StatusMDecision* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MissionDecision_StatusMDecision>(
    MissionDecision_StatusMDecision_descriptor(), name, value);
}
enum DDTDecision_ObjectDecision_type : int {
  DDTDecision_ObjectDecision_type_O_IGNORE = 0,
  DDTDecision_ObjectDecision_type_O_STOP = 1,
  DDTDecision_ObjectDecision_type_O_FOLLOW = 2,
  DDTDecision_ObjectDecision_type_O_OVERTAKE = 3,
  DDTDecision_ObjectDecision_type_O_YIELD = 4,
  DDTDecision_ObjectDecision_type_O_BYPASS = 5,
  DDTDecision_ObjectDecision_type_DDTDecision_ObjectDecision_type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DDTDecision_ObjectDecision_type_DDTDecision_ObjectDecision_type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DDTDecision_ObjectDecision_type_IsValid(int value);
constexpr DDTDecision_ObjectDecision_type DDTDecision_ObjectDecision_type_type_MIN = DDTDecision_ObjectDecision_type_O_IGNORE;
constexpr DDTDecision_ObjectDecision_type DDTDecision_ObjectDecision_type_type_MAX = DDTDecision_ObjectDecision_type_O_BYPASS;
constexpr int DDTDecision_ObjectDecision_type_type_ARRAYSIZE = DDTDecision_ObjectDecision_type_type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DDTDecision_ObjectDecision_type_descriptor();
template<typename T>
inline const std::string& DDTDecision_ObjectDecision_type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DDTDecision_ObjectDecision_type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DDTDecision_ObjectDecision_type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DDTDecision_ObjectDecision_type_descriptor(), enum_t_value);
}
inline bool DDTDecision_ObjectDecision_type_Parse(
    const std::string& name, DDTDecision_ObjectDecision_type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DDTDecision_ObjectDecision_type>(
    DDTDecision_ObjectDecision_type_descriptor(), name, value);
}
enum DDTDecision_ObjectDecision_DDTState : int {
  DDTDecision_ObjectDecision_DDTState_NORMAL = 0,
  DDTDecision_ObjectDecision_DDTState_EMERGENCY = 1,
  DDTDecision_ObjectDecision_DDTState_COLLSION_WARNING = 2,
  DDTDecision_ObjectDecision_DDTState_FAILURE_DECTECTED = 3,
  DDTDecision_ObjectDecision_DDTState_DDTDecision_ObjectDecision_DDTState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DDTDecision_ObjectDecision_DDTState_DDTDecision_ObjectDecision_DDTState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DDTDecision_ObjectDecision_DDTState_IsValid(int value);
constexpr DDTDecision_ObjectDecision_DDTState DDTDecision_ObjectDecision_DDTState_DDTState_MIN = DDTDecision_ObjectDecision_DDTState_NORMAL;
constexpr DDTDecision_ObjectDecision_DDTState DDTDecision_ObjectDecision_DDTState_DDTState_MAX = DDTDecision_ObjectDecision_DDTState_FAILURE_DECTECTED;
constexpr int DDTDecision_ObjectDecision_DDTState_DDTState_ARRAYSIZE = DDTDecision_ObjectDecision_DDTState_DDTState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DDTDecision_ObjectDecision_DDTState_descriptor();
template<typename T>
inline const std::string& DDTDecision_ObjectDecision_DDTState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DDTDecision_ObjectDecision_DDTState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DDTDecision_ObjectDecision_DDTState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DDTDecision_ObjectDecision_DDTState_descriptor(), enum_t_value);
}
inline bool DDTDecision_ObjectDecision_DDTState_Parse(
    const std::string& name, DDTDecision_ObjectDecision_DDTState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DDTDecision_ObjectDecision_DDTState>(
    DDTDecision_ObjectDecision_DDTState_descriptor(), name, value);
}
enum TrajectoryType : int {
  UNKNOWN = 0,
  NORMAL = 1,
  FALLBACK = 2,
  TrajectoryType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TrajectoryType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TrajectoryType_IsValid(int value);
constexpr TrajectoryType TrajectoryType_MIN = UNKNOWN;
constexpr TrajectoryType TrajectoryType_MAX = FALLBACK;
constexpr int TrajectoryType_ARRAYSIZE = TrajectoryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrajectoryType_descriptor();
template<typename T>
inline const std::string& TrajectoryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrajectoryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrajectoryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrajectoryType_descriptor(), enum_t_value);
}
inline bool TrajectoryType_Parse(
    const std::string& name, TrajectoryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrajectoryType>(
    TrajectoryType_descriptor(), name, value);
}
enum DebugPointType : int {
  AUTO_DRIVE_BOUNDARY = 0,
  REF_LINE = 1,
  OBS_SL_BOUNDARY = 2,
  OBS_POLYGON_BOUNDARY = 3,
  OBS_BOX_BOUNDARY = 4,
  OTHER1 = 5,
  OTHER2 = 6,
  LOCAL_PATH = 7,
  TRACJETORY = 8,
  ALL_LOCAL_PATH = 9,
  PATH_BOUNDARY = 10,
  PATH_BOUNDARY_OF_FALLBACK = 11,
  ROUTING_LANE_INFO = 12,
  WORKING_DEBUG_INFO = 13,
  DebugPointType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DebugPointType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DebugPointType_IsValid(int value);
constexpr DebugPointType DebugPointType_MIN = AUTO_DRIVE_BOUNDARY;
constexpr DebugPointType DebugPointType_MAX = WORKING_DEBUG_INFO;
constexpr int DebugPointType_ARRAYSIZE = DebugPointType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DebugPointType_descriptor();
template<typename T>
inline const std::string& DebugPointType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DebugPointType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DebugPointType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DebugPointType_descriptor(), enum_t_value);
}
inline bool DebugPointType_Parse(
    const std::string& name, DebugPointType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DebugPointType>(
    DebugPointType_descriptor(), name, value);
}
enum GearType : int {
  GEAR_INVALID = 0,
  GEAR_N = 1,
  GEAR_D = 2,
  GEAR_R = 3,
  GEAR_L = 4,
  GEAR_P = 5,
  GearType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GearType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GearType_IsValid(int value);
constexpr GearType GearType_MIN = GEAR_INVALID;
constexpr GearType GearType_MAX = GEAR_P;
constexpr int GearType_ARRAYSIZE = GearType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GearType_descriptor();
template<typename T>
inline const std::string& GearType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GearType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GearType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GearType_descriptor(), enum_t_value);
}
inline bool GearType_Parse(
    const std::string& name, GearType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GearType>(
    GearType_descriptor(), name, value);
}
enum ThrottleFlagType : int {
  THROT_INVALID = 0,
  THROT_UNACTIVATE = 1,
  THROT_ACTIVATE = 2,
  ThrottleFlagType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ThrottleFlagType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ThrottleFlagType_IsValid(int value);
constexpr ThrottleFlagType ThrottleFlagType_MIN = THROT_INVALID;
constexpr ThrottleFlagType ThrottleFlagType_MAX = THROT_ACTIVATE;
constexpr int ThrottleFlagType_ARRAYSIZE = ThrottleFlagType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ThrottleFlagType_descriptor();
template<typename T>
inline const std::string& ThrottleFlagType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ThrottleFlagType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ThrottleFlagType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ThrottleFlagType_descriptor(), enum_t_value);
}
inline bool ThrottleFlagType_Parse(
    const std::string& name, ThrottleFlagType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ThrottleFlagType>(
    ThrottleFlagType_descriptor(), name, value);
}
enum BrakeFlagType : int {
  BRAKE_INVALID = 0,
  NO_BRAKE = 1,
  BRAKE_XBR = 2,
  BRAKE_HUMAN = 3,
  BRAKE_PERCENT = 4,
  BrakeFlagType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BrakeFlagType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BrakeFlagType_IsValid(int value);
constexpr BrakeFlagType BrakeFlagType_MIN = BRAKE_INVALID;
constexpr BrakeFlagType BrakeFlagType_MAX = BRAKE_PERCENT;
constexpr int BrakeFlagType_ARRAYSIZE = BrakeFlagType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BrakeFlagType_descriptor();
template<typename T>
inline const std::string& BrakeFlagType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BrakeFlagType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BrakeFlagType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BrakeFlagType_descriptor(), enum_t_value);
}
inline bool BrakeFlagType_Parse(
    const std::string& name, BrakeFlagType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BrakeFlagType>(
    BrakeFlagType_descriptor(), name, value);
}
enum EpbType : int {
  EPB_INVALID = 0,
  EPB_OFF = 1,
  EPB_ON = 2,
  EpbType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EpbType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EpbType_IsValid(int value);
constexpr EpbType EpbType_MIN = EPB_INVALID;
constexpr EpbType EpbType_MAX = EPB_ON;
constexpr int EpbType_ARRAYSIZE = EpbType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EpbType_descriptor();
template<typename T>
inline const std::string& EpbType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EpbType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EpbType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EpbType_descriptor(), enum_t_value);
}
inline bool EpbType_Parse(
    const std::string& name, EpbType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EpbType>(
    EpbType_descriptor(), name, value);
}
// ===================================================================

class Recommendation :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IBUS.Recommendation) */ {
 public:
  Recommendation();
  virtual ~Recommendation();

  Recommendation(const Recommendation& from);
  Recommendation(Recommendation&& from) noexcept
    : Recommendation() {
    *this = ::std::move(from);
  }

  inline Recommendation& operator=(const Recommendation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Recommendation& operator=(Recommendation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Recommendation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Recommendation* internal_default_instance() {
    return reinterpret_cast<const Recommendation*>(
               &_Recommendation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Recommendation& a, Recommendation& b) {
    a.Swap(&b);
  }
  inline void Swap(Recommendation* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Recommendation* New() const final {
    return CreateMaybeMessage<Recommendation>(nullptr);
  }

  Recommendation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Recommendation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Recommendation& from);
  void MergeFrom(const Recommendation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Recommendation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IBUS.Recommendation";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_DecisonInterface_2eproto);
    return ::descriptor_table_DecisonInterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentSequenceIDsFieldNumber = 1,
    kTargetSequeceIDsFieldNumber = 2,
    kSpeedLimitsFieldNumber = 3,
  };
  // uint64 CurrentSequenceIDs = 1;
  void clear_currentsequenceids();
  ::PROTOBUF_NAMESPACE_ID::uint64 currentsequenceids() const;
  void set_currentsequenceids(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint64 TargetSequeceIDs = 2;
  void clear_targetsequeceids();
  ::PROTOBUF_NAMESPACE_ID::uint64 targetsequeceids() const;
  void set_targetsequeceids(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint32 SpeedLimits = 3;
  void clear_speedlimits();
  ::PROTOBUF_NAMESPACE_ID::uint32 speedlimits() const;
  void set_speedlimits(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:IBUS.Recommendation)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 currentsequenceids_;
  ::PROTOBUF_NAMESPACE_ID::uint64 targetsequeceids_;
  ::PROTOBUF_NAMESPACE_ID::uint32 speedlimits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DecisonInterface_2eproto;
};
// -------------------------------------------------------------------

class MissionDecision :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IBUS.MissionDecision) */ {
 public:
  MissionDecision();
  virtual ~MissionDecision();

  MissionDecision(const MissionDecision& from);
  MissionDecision(MissionDecision&& from) noexcept
    : MissionDecision() {
    *this = ::std::move(from);
  }

  inline MissionDecision& operator=(const MissionDecision& from) {
    CopyFrom(from);
    return *this;
  }
  inline MissionDecision& operator=(MissionDecision&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MissionDecision& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MissionDecision* internal_default_instance() {
    return reinterpret_cast<const MissionDecision*>(
               &_MissionDecision_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MissionDecision& a, MissionDecision& b) {
    a.Swap(&b);
  }
  inline void Swap(MissionDecision* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MissionDecision* New() const final {
    return CreateMaybeMessage<MissionDecision>(nullptr);
  }

  MissionDecision* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MissionDecision>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MissionDecision& from);
  void MergeFrom(const MissionDecision& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MissionDecision* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IBUS.MissionDecision";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_DecisonInterface_2eproto);
    return ::descriptor_table_DecisonInterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef MissionDecision_MissionType MissionType;
  static constexpr MissionType END_POINT =
    MissionDecision_MissionType_END_POINT;
  static constexpr MissionType CRUISE =
    MissionDecision_MissionType_CRUISE;
  static constexpr MissionType STOP =
    MissionDecision_MissionType_STOP;
  static constexpr MissionType LANE_CHANGE_LEFT =
    MissionDecision_MissionType_LANE_CHANGE_LEFT;
  static constexpr MissionType LANE_CHANGE_RIGHT =
    MissionDecision_MissionType_LANE_CHANGE_RIGHT;
  static constexpr MissionType PARKING =
    MissionDecision_MissionType_PARKING;
  static constexpr MissionType U_TURN =
    MissionDecision_MissionType_U_TURN;
  static constexpr MissionType TURN_LEFT =
    MissionDecision_MissionType_TURN_LEFT;
  static constexpr MissionType TURN_RIGHT =
    MissionDecision_MissionType_TURN_RIGHT;
  static constexpr MissionType WORKING_L =
    MissionDecision_MissionType_WORKING_L;
  static constexpr MissionType WORKING_R =
    MissionDecision_MissionType_WORKING_R;
  static constexpr MissionType WORKING_ALL =
    MissionDecision_MissionType_WORKING_ALL;
  static constexpr MissionType LANE_BORROW_L =
    MissionDecision_MissionType_LANE_BORROW_L;
  static constexpr MissionType LANE_BORROW_R =
    MissionDecision_MissionType_LANE_BORROW_R;
  static inline bool MissionType_IsValid(int value) {
    return MissionDecision_MissionType_IsValid(value);
  }
  static constexpr MissionType MissionType_MIN =
    MissionDecision_MissionType_MissionType_MIN;
  static constexpr MissionType MissionType_MAX =
    MissionDecision_MissionType_MissionType_MAX;
  static constexpr int MissionType_ARRAYSIZE =
    MissionDecision_MissionType_MissionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MissionType_descriptor() {
    return MissionDecision_MissionType_descriptor();
  }
  template<typename T>
  static inline const std::string& MissionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MissionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MissionType_Name.");
    return MissionDecision_MissionType_Name(enum_t_value);
  }
  static inline bool MissionType_Parse(const std::string& name,
      MissionType* value) {
    return MissionDecision_MissionType_Parse(name, value);
  }

  typedef MissionDecision_StatusMDecision StatusMDecision;
  static constexpr StatusMDecision NORMAL =
    MissionDecision_StatusMDecision_NORMAL;
  static constexpr StatusMDecision EMERGENCY =
    MissionDecision_StatusMDecision_EMERGENCY;
  static constexpr StatusMDecision COLLSION_WARNING =
    MissionDecision_StatusMDecision_COLLSION_WARNING;
  static constexpr StatusMDecision FAILURE_DECTECTED =
    MissionDecision_StatusMDecision_FAILURE_DECTECTED;
  static inline bool StatusMDecision_IsValid(int value) {
    return MissionDecision_StatusMDecision_IsValid(value);
  }
  static constexpr StatusMDecision StatusMDecision_MIN =
    MissionDecision_StatusMDecision_StatusMDecision_MIN;
  static constexpr StatusMDecision StatusMDecision_MAX =
    MissionDecision_StatusMDecision_StatusMDecision_MAX;
  static constexpr int StatusMDecision_ARRAYSIZE =
    MissionDecision_StatusMDecision_StatusMDecision_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StatusMDecision_descriptor() {
    return MissionDecision_StatusMDecision_descriptor();
  }
  template<typename T>
  static inline const std::string& StatusMDecision_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StatusMDecision>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StatusMDecision_Name.");
    return MissionDecision_StatusMDecision_Name(enum_t_value);
  }
  static inline bool StatusMDecision_Parse(const std::string& name,
      StatusMDecision* value) {
    return MissionDecision_StatusMDecision_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kParkingPointFieldNumber = 6,
    kTypeFieldNumber = 1,
    kLaneAttachedFieldNumber = 2,
    kHeadingAttachedFieldNumber = 4,
    kParkingLotsAttachedFieldNumber = 3,
    kStatusAttachedFieldNumber = 5,
  };
  // .IBUS.Point2D ParkingPoint = 6;
  bool has_parkingpoint() const;
  void clear_parkingpoint();
  const ::IBUS::Point2D& parkingpoint() const;
  ::IBUS::Point2D* release_parkingpoint();
  ::IBUS::Point2D* mutable_parkingpoint();
  void set_allocated_parkingpoint(::IBUS::Point2D* parkingpoint);

  // .IBUS.MissionDecision.MissionType type = 1;
  void clear_type();
  ::IBUS::MissionDecision_MissionType type() const;
  void set_type(::IBUS::MissionDecision_MissionType value);

  // uint32 LaneAttached = 2;
  void clear_laneattached();
  ::PROTOBUF_NAMESPACE_ID::uint32 laneattached() const;
  void set_laneattached(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // double HeadingAttached = 4;
  void clear_headingattached();
  double headingattached() const;
  void set_headingattached(double value);

  // uint32 ParkingLotsAttached = 3;
  void clear_parkinglotsattached();
  ::PROTOBUF_NAMESPACE_ID::uint32 parkinglotsattached() const;
  void set_parkinglotsattached(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // .IBUS.MissionDecision.StatusMDecision StatusAttached = 5;
  void clear_statusattached();
  ::IBUS::MissionDecision_StatusMDecision statusattached() const;
  void set_statusattached(::IBUS::MissionDecision_StatusMDecision value);

  // @@protoc_insertion_point(class_scope:IBUS.MissionDecision)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::IBUS::Point2D* parkingpoint_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 laneattached_;
  double headingattached_;
  ::PROTOBUF_NAMESPACE_ID::uint32 parkinglotsattached_;
  int statusattached_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DecisonInterface_2eproto;
};
// -------------------------------------------------------------------

class DDTDecision_ObjectDecision :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IBUS.DDTDecision.ObjectDecision) */ {
 public:
  DDTDecision_ObjectDecision();
  virtual ~DDTDecision_ObjectDecision();

  DDTDecision_ObjectDecision(const DDTDecision_ObjectDecision& from);
  DDTDecision_ObjectDecision(DDTDecision_ObjectDecision&& from) noexcept
    : DDTDecision_ObjectDecision() {
    *this = ::std::move(from);
  }

  inline DDTDecision_ObjectDecision& operator=(const DDTDecision_ObjectDecision& from) {
    CopyFrom(from);
    return *this;
  }
  inline DDTDecision_ObjectDecision& operator=(DDTDecision_ObjectDecision&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DDTDecision_ObjectDecision& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DDTDecision_ObjectDecision* internal_default_instance() {
    return reinterpret_cast<const DDTDecision_ObjectDecision*>(
               &_DDTDecision_ObjectDecision_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DDTDecision_ObjectDecision& a, DDTDecision_ObjectDecision& b) {
    a.Swap(&b);
  }
  inline void Swap(DDTDecision_ObjectDecision* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DDTDecision_ObjectDecision* New() const final {
    return CreateMaybeMessage<DDTDecision_ObjectDecision>(nullptr);
  }

  DDTDecision_ObjectDecision* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DDTDecision_ObjectDecision>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DDTDecision_ObjectDecision& from);
  void MergeFrom(const DDTDecision_ObjectDecision& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DDTDecision_ObjectDecision* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IBUS.DDTDecision.ObjectDecision";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_DecisonInterface_2eproto);
    return ::descriptor_table_DecisonInterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef DDTDecision_ObjectDecision_type type;
  static constexpr type O_IGNORE =
    DDTDecision_ObjectDecision_type_O_IGNORE;
  static constexpr type O_STOP =
    DDTDecision_ObjectDecision_type_O_STOP;
  static constexpr type O_FOLLOW =
    DDTDecision_ObjectDecision_type_O_FOLLOW;
  static constexpr type O_OVERTAKE =
    DDTDecision_ObjectDecision_type_O_OVERTAKE;
  static constexpr type O_YIELD =
    DDTDecision_ObjectDecision_type_O_YIELD;
  static constexpr type O_BYPASS =
    DDTDecision_ObjectDecision_type_O_BYPASS;
  static inline bool type_IsValid(int value) {
    return DDTDecision_ObjectDecision_type_IsValid(value);
  }
  static constexpr type type_MIN =
    DDTDecision_ObjectDecision_type_type_MIN;
  static constexpr type type_MAX =
    DDTDecision_ObjectDecision_type_type_MAX;
  static constexpr int type_ARRAYSIZE =
    DDTDecision_ObjectDecision_type_type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  type_descriptor() {
    return DDTDecision_ObjectDecision_type_descriptor();
  }
  template<typename T>
  static inline const std::string& type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function type_Name.");
    return DDTDecision_ObjectDecision_type_Name(enum_t_value);
  }
  static inline bool type_Parse(const std::string& name,
      type* value) {
    return DDTDecision_ObjectDecision_type_Parse(name, value);
  }

  typedef DDTDecision_ObjectDecision_DDTState DDTState;
  static constexpr DDTState NORMAL =
    DDTDecision_ObjectDecision_DDTState_NORMAL;
  static constexpr DDTState EMERGENCY =
    DDTDecision_ObjectDecision_DDTState_EMERGENCY;
  static constexpr DDTState COLLSION_WARNING =
    DDTDecision_ObjectDecision_DDTState_COLLSION_WARNING;
  static constexpr DDTState FAILURE_DECTECTED =
    DDTDecision_ObjectDecision_DDTState_FAILURE_DECTECTED;
  static inline bool DDTState_IsValid(int value) {
    return DDTDecision_ObjectDecision_DDTState_IsValid(value);
  }
  static constexpr DDTState DDTState_MIN =
    DDTDecision_ObjectDecision_DDTState_DDTState_MIN;
  static constexpr DDTState DDTState_MAX =
    DDTDecision_ObjectDecision_DDTState_DDTState_MAX;
  static constexpr int DDTState_ARRAYSIZE =
    DDTDecision_ObjectDecision_DDTState_DDTState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DDTState_descriptor() {
    return DDTDecision_ObjectDecision_DDTState_descriptor();
  }
  template<typename T>
  static inline const std::string& DDTState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DDTState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DDTState_Name.");
    return DDTDecision_ObjectDecision_DDTState_Name(enum_t_value);
  }
  static inline bool DDTState_Parse(const std::string& name,
      DDTState* value) {
    return DDTDecision_ObjectDecision_DDTState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIDFieldNumber = 1,
    kObjectDTypeFieldNumber = 2,
    kHeadingAttachedFieldNumber = 3,
    kSafetLateralDistanceFieldNumber = 5,
    kSafetyLongitudinalDistanceFieldNumber = 6,
    kStatusAttachedFieldNumber = 4,
  };
  // uint32 ObjectID = 1;
  void clear_objectid();
  ::PROTOBUF_NAMESPACE_ID::uint32 objectid() const;
  void set_objectid(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // .IBUS.DDTDecision.ObjectDecision.type ObjectDType = 2;
  void clear_objectdtype();
  ::IBUS::DDTDecision_ObjectDecision_type objectdtype() const;
  void set_objectdtype(::IBUS::DDTDecision_ObjectDecision_type value);

  // double HeadingAttached = 3;
  void clear_headingattached();
  double headingattached() const;
  void set_headingattached(double value);

  // double SafetLateralDistance = 5;
  void clear_safetlateraldistance();
  double safetlateraldistance() const;
  void set_safetlateraldistance(double value);

  // double SafetyLongitudinalDistance = 6;
  void clear_safetylongitudinaldistance();
  double safetylongitudinaldistance() const;
  void set_safetylongitudinaldistance(double value);

  // .IBUS.DDTDecision.ObjectDecision.DDTState StatusAttached = 4;
  void clear_statusattached();
  ::IBUS::DDTDecision_ObjectDecision_DDTState statusattached() const;
  void set_statusattached(::IBUS::DDTDecision_ObjectDecision_DDTState value);

  // @@protoc_insertion_point(class_scope:IBUS.DDTDecision.ObjectDecision)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 objectid_;
  int objectdtype_;
  double headingattached_;
  double safetlateraldistance_;
  double safetylongitudinaldistance_;
  int statusattached_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DecisonInterface_2eproto;
};
// -------------------------------------------------------------------

class DDTDecision :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IBUS.DDTDecision) */ {
 public:
  DDTDecision();
  virtual ~DDTDecision();

  DDTDecision(const DDTDecision& from);
  DDTDecision(DDTDecision&& from) noexcept
    : DDTDecision() {
    *this = ::std::move(from);
  }

  inline DDTDecision& operator=(const DDTDecision& from) {
    CopyFrom(from);
    return *this;
  }
  inline DDTDecision& operator=(DDTDecision&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DDTDecision& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DDTDecision* internal_default_instance() {
    return reinterpret_cast<const DDTDecision*>(
               &_DDTDecision_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DDTDecision& a, DDTDecision& b) {
    a.Swap(&b);
  }
  inline void Swap(DDTDecision* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DDTDecision* New() const final {
    return CreateMaybeMessage<DDTDecision>(nullptr);
  }

  DDTDecision* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DDTDecision>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DDTDecision& from);
  void MergeFrom(const DDTDecision& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DDTDecision* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IBUS.DDTDecision";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_DecisonInterface_2eproto);
    return ::descriptor_table_DecisonInterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef DDTDecision_ObjectDecision ObjectDecision;

  // accessors -------------------------------------------------------

  enum : int {
    kObjectsDecisionsFieldNumber = 1,
  };
  // repeated .IBUS.DDTDecision.ObjectDecision ObjectsDecisions = 1;
  int objectsdecisions_size() const;
  void clear_objectsdecisions();
  ::IBUS::DDTDecision_ObjectDecision* mutable_objectsdecisions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::DDTDecision_ObjectDecision >*
      mutable_objectsdecisions();
  const ::IBUS::DDTDecision_ObjectDecision& objectsdecisions(int index) const;
  ::IBUS::DDTDecision_ObjectDecision* add_objectsdecisions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::DDTDecision_ObjectDecision >&
      objectsdecisions() const;

  // @@protoc_insertion_point(class_scope:IBUS.DDTDecision)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::DDTDecision_ObjectDecision > objectsdecisions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DecisonInterface_2eproto;
};
// -------------------------------------------------------------------

class TrajectoryPoint :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IBUS.TrajectoryPoint) */ {
 public:
  TrajectoryPoint();
  virtual ~TrajectoryPoint();

  TrajectoryPoint(const TrajectoryPoint& from);
  TrajectoryPoint(TrajectoryPoint&& from) noexcept
    : TrajectoryPoint() {
    *this = ::std::move(from);
  }

  inline TrajectoryPoint& operator=(const TrajectoryPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrajectoryPoint& operator=(TrajectoryPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrajectoryPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrajectoryPoint* internal_default_instance() {
    return reinterpret_cast<const TrajectoryPoint*>(
               &_TrajectoryPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TrajectoryPoint& a, TrajectoryPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(TrajectoryPoint* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrajectoryPoint* New() const final {
    return CreateMaybeMessage<TrajectoryPoint>(nullptr);
  }

  TrajectoryPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrajectoryPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrajectoryPoint& from);
  void MergeFrom(const TrajectoryPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrajectoryPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IBUS.TrajectoryPoint";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_DecisonInterface_2eproto);
    return ::descriptor_table_DecisonInterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kThetaFieldNumber = 2,
    kKappaFieldNumber = 3,
    kTimeRelativeToStartFieldNumber = 5,
    kHeadingFieldNumber = 6,
    kSpeedFieldNumber = 7,
    kAccelFieldNumber = 8,
    kGradeFieldNumber = 9,
    kSFieldNumber = 10,
    kSteerFieldNumber = 11,
    kLaneIDFieldNumber = 4,
  };
  // .IBUS.Point3D position = 1;
  bool has_position() const;
  void clear_position();
  const ::IBUS::Point3D& position() const;
  ::IBUS::Point3D* release_position();
  ::IBUS::Point3D* mutable_position();
  void set_allocated_position(::IBUS::Point3D* position);

  // double theta = 2;
  void clear_theta();
  double theta() const;
  void set_theta(double value);

  // double kappa = 3;
  void clear_kappa();
  double kappa() const;
  void set_kappa(double value);

  // double TimeRelativeToStart = 5;
  void clear_timerelativetostart();
  double timerelativetostart() const;
  void set_timerelativetostart(double value);

  // double Heading = 6;
  void clear_heading();
  double heading() const;
  void set_heading(double value);

  // double Speed = 7;
  void clear_speed();
  double speed() const;
  void set_speed(double value);

  // double Accel = 8;
  void clear_accel();
  double accel() const;
  void set_accel(double value);

  // double grade = 9;
  void clear_grade();
  double grade() const;
  void set_grade(double value);

  // double s = 10;
  void clear_s();
  double s() const;
  void set_s(double value);

  // double steer = 11;
  void clear_steer();
  double steer() const;
  void set_steer(double value);

  // uint32 laneID = 4;
  void clear_laneid();
  ::PROTOBUF_NAMESPACE_ID::uint32 laneid() const;
  void set_laneid(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:IBUS.TrajectoryPoint)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::IBUS::Point3D* position_;
  double theta_;
  double kappa_;
  double timerelativetostart_;
  double heading_;
  double speed_;
  double accel_;
  double grade_;
  double s_;
  double steer_;
  ::PROTOBUF_NAMESPACE_ID::uint32 laneid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DecisonInterface_2eproto;
};
// -------------------------------------------------------------------

class RefLinePoint :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IBUS.RefLinePoint) */ {
 public:
  RefLinePoint();
  virtual ~RefLinePoint();

  RefLinePoint(const RefLinePoint& from);
  RefLinePoint(RefLinePoint&& from) noexcept
    : RefLinePoint() {
    *this = ::std::move(from);
  }

  inline RefLinePoint& operator=(const RefLinePoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefLinePoint& operator=(RefLinePoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RefLinePoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RefLinePoint* internal_default_instance() {
    return reinterpret_cast<const RefLinePoint*>(
               &_RefLinePoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RefLinePoint& a, RefLinePoint& b) {
    a.Swap(&b);
  }
  inline void Swap(RefLinePoint* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RefLinePoint* New() const final {
    return CreateMaybeMessage<RefLinePoint>(nullptr);
  }

  RefLinePoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RefLinePoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RefLinePoint& from);
  void MergeFrom(const RefLinePoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefLinePoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IBUS.RefLinePoint";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_DecisonInterface_2eproto);
    return ::descriptor_table_DecisonInterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 3,
    kSFieldNumber = 1,
    kLFieldNumber = 2,
    kThetaFieldNumber = 4,
    kKappaFieldNumber = 5,
    kGradeFieldNumber = 6,
    kWidthFieldNumber = 7,
    kLaneidFieldNumber = 8,
  };
  // .IBUS.Point3D point = 3;
  bool has_point() const;
  void clear_point();
  const ::IBUS::Point3D& point() const;
  ::IBUS::Point3D* release_point();
  ::IBUS::Point3D* mutable_point();
  void set_allocated_point(::IBUS::Point3D* point);

  // double s = 1;
  void clear_s();
  double s() const;
  void set_s(double value);

  // double l = 2;
  void clear_l();
  double l() const;
  void set_l(double value);

  // double theta = 4;
  void clear_theta();
  double theta() const;
  void set_theta(double value);

  // double kappa = 5;
  void clear_kappa();
  double kappa() const;
  void set_kappa(double value);

  // double grade = 6;
  void clear_grade();
  double grade() const;
  void set_grade(double value);

  // double width = 7;
  void clear_width();
  double width() const;
  void set_width(double value);

  // double laneid = 8;
  void clear_laneid();
  double laneid() const;
  void set_laneid(double value);

  // @@protoc_insertion_point(class_scope:IBUS.RefLinePoint)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::IBUS::Point3D* point_;
  double s_;
  double l_;
  double theta_;
  double kappa_;
  double grade_;
  double width_;
  double laneid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DecisonInterface_2eproto;
};
// -------------------------------------------------------------------

class PathBoundPoint :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IBUS.PathBoundPoint) */ {
 public:
  PathBoundPoint();
  virtual ~PathBoundPoint();

  PathBoundPoint(const PathBoundPoint& from);
  PathBoundPoint(PathBoundPoint&& from) noexcept
    : PathBoundPoint() {
    *this = ::std::move(from);
  }

  inline PathBoundPoint& operator=(const PathBoundPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathBoundPoint& operator=(PathBoundPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PathBoundPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PathBoundPoint* internal_default_instance() {
    return reinterpret_cast<const PathBoundPoint*>(
               &_PathBoundPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PathBoundPoint& a, PathBoundPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(PathBoundPoint* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PathBoundPoint* New() const final {
    return CreateMaybeMessage<PathBoundPoint>(nullptr);
  }

  PathBoundPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PathBoundPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PathBoundPoint& from);
  void MergeFrom(const PathBoundPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathBoundPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IBUS.PathBoundPoint";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_DecisonInterface_2eproto);
    return ::descriptor_table_DecisonInterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathBoundLFieldNumber = 1,
    kPathBoundRFieldNumber = 2,
    kLaneBoundLFieldNumber = 3,
    kLaneBoundRFieldNumber = 4,
  };
  // .IBUS.Point2D PathBoundL = 1;
  bool has_pathboundl() const;
  void clear_pathboundl();
  const ::IBUS::Point2D& pathboundl() const;
  ::IBUS::Point2D* release_pathboundl();
  ::IBUS::Point2D* mutable_pathboundl();
  void set_allocated_pathboundl(::IBUS::Point2D* pathboundl);

  // .IBUS.Point2D PathBoundR = 2;
  bool has_pathboundr() const;
  void clear_pathboundr();
  const ::IBUS::Point2D& pathboundr() const;
  ::IBUS::Point2D* release_pathboundr();
  ::IBUS::Point2D* mutable_pathboundr();
  void set_allocated_pathboundr(::IBUS::Point2D* pathboundr);

  // .IBUS.Point2D LaneBoundL = 3;
  bool has_laneboundl() const;
  void clear_laneboundl();
  const ::IBUS::Point2D& laneboundl() const;
  ::IBUS::Point2D* release_laneboundl();
  ::IBUS::Point2D* mutable_laneboundl();
  void set_allocated_laneboundl(::IBUS::Point2D* laneboundl);

  // .IBUS.Point2D LaneBoundR = 4;
  bool has_laneboundr() const;
  void clear_laneboundr();
  const ::IBUS::Point2D& laneboundr() const;
  ::IBUS::Point2D* release_laneboundr();
  ::IBUS::Point2D* mutable_laneboundr();
  void set_allocated_laneboundr(::IBUS::Point2D* laneboundr);

  // @@protoc_insertion_point(class_scope:IBUS.PathBoundPoint)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::IBUS::Point2D* pathboundl_;
  ::IBUS::Point2D* pathboundr_;
  ::IBUS::Point2D* laneboundl_;
  ::IBUS::Point2D* laneboundr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DecisonInterface_2eproto;
};
// -------------------------------------------------------------------

class DebugPointInf :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IBUS.DebugPointInf) */ {
 public:
  DebugPointInf();
  virtual ~DebugPointInf();

  DebugPointInf(const DebugPointInf& from);
  DebugPointInf(DebugPointInf&& from) noexcept
    : DebugPointInf() {
    *this = ::std::move(from);
  }

  inline DebugPointInf& operator=(const DebugPointInf& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugPointInf& operator=(DebugPointInf&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DebugPointInf& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugPointInf* internal_default_instance() {
    return reinterpret_cast<const DebugPointInf*>(
               &_DebugPointInf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DebugPointInf& a, DebugPointInf& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugPointInf* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DebugPointInf* New() const final {
    return CreateMaybeMessage<DebugPointInf>(nullptr);
  }

  DebugPointInf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DebugPointInf>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DebugPointInf& from);
  void MergeFrom(const DebugPointInf& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugPointInf* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IBUS.DebugPointInf";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_DecisonInterface_2eproto);
    return ::descriptor_table_DecisonInterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDebugPointFieldNumber = 1,
    kPointLabelFieldNumber = 3,
    kPointTypeFieldNumber = 2,
  };
  // repeated .IBUS.Point2D DebugPoint = 1;
  int debugpoint_size() const;
  void clear_debugpoint();
  ::IBUS::Point2D* mutable_debugpoint(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::Point2D >*
      mutable_debugpoint();
  const ::IBUS::Point2D& debugpoint(int index) const;
  ::IBUS::Point2D* add_debugpoint();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::Point2D >&
      debugpoint() const;

  // string PointLabel = 3;
  void clear_pointlabel();
  const std::string& pointlabel() const;
  void set_pointlabel(const std::string& value);
  void set_pointlabel(std::string&& value);
  void set_pointlabel(const char* value);
  void set_pointlabel(const char* value, size_t size);
  std::string* mutable_pointlabel();
  std::string* release_pointlabel();
  void set_allocated_pointlabel(std::string* pointlabel);

  // .IBUS.DebugPointType PointType = 2;
  void clear_pointtype();
  ::IBUS::DebugPointType pointtype() const;
  void set_pointtype(::IBUS::DebugPointType value);

  // @@protoc_insertion_point(class_scope:IBUS.DebugPointInf)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::Point2D > debugpoint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pointlabel_;
  int pointtype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DecisonInterface_2eproto;
};
// -------------------------------------------------------------------

class ControlPointInf :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IBUS.ControlPointInf) */ {
 public:
  ControlPointInf();
  virtual ~ControlPointInf();

  ControlPointInf(const ControlPointInf& from);
  ControlPointInf(ControlPointInf&& from) noexcept
    : ControlPointInf() {
    *this = ::std::move(from);
  }

  inline ControlPointInf& operator=(const ControlPointInf& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlPointInf& operator=(ControlPointInf&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControlPointInf& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlPointInf* internal_default_instance() {
    return reinterpret_cast<const ControlPointInf*>(
               &_ControlPointInf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ControlPointInf& a, ControlPointInf& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlPointInf* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControlPointInf* New() const final {
    return CreateMaybeMessage<ControlPointInf>(nullptr);
  }

  ControlPointInf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControlPointInf>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControlPointInf& from);
  void MergeFrom(const ControlPointInf& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlPointInf* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IBUS.ControlPointInf";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_DecisonInterface_2eproto);
    return ::descriptor_table_DecisonInterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccelerationCmdFieldNumber = 2,
    kGearCmdFieldNumber = 1,
    kThrottleFlagCmdFieldNumber = 3,
    kThrottleCmdFieldNumber = 4,
    kBrakeCmdFieldNumber = 6,
    kBrakeFlagCmdFieldNumber = 5,
    kEPBCmdFieldNumber = 8,
    kSteeringCmdFieldNumber = 7,
  };
  // double AccelerationCmd = 2;
  void clear_accelerationcmd();
  double accelerationcmd() const;
  void set_accelerationcmd(double value);

  // .IBUS.GearType GearCmd = 1;
  void clear_gearcmd();
  ::IBUS::GearType gearcmd() const;
  void set_gearcmd(::IBUS::GearType value);

  // .IBUS.ThrottleFlagType ThrottleFlagCmd = 3;
  void clear_throttleflagcmd();
  ::IBUS::ThrottleFlagType throttleflagcmd() const;
  void set_throttleflagcmd(::IBUS::ThrottleFlagType value);

  // double ThrottleCmd = 4;
  void clear_throttlecmd();
  double throttlecmd() const;
  void set_throttlecmd(double value);

  // double BrakeCmd = 6;
  void clear_brakecmd();
  double brakecmd() const;
  void set_brakecmd(double value);

  // .IBUS.BrakeFlagType BrakeFlagCmd = 5;
  void clear_brakeflagcmd();
  ::IBUS::BrakeFlagType brakeflagcmd() const;
  void set_brakeflagcmd(::IBUS::BrakeFlagType value);

  // .IBUS.EpbType EPBCmd = 8;
  void clear_epbcmd();
  ::IBUS::EpbType epbcmd() const;
  void set_epbcmd(::IBUS::EpbType value);

  // double SteeringCmd = 7;
  void clear_steeringcmd();
  double steeringcmd() const;
  void set_steeringcmd(double value);

  // @@protoc_insertion_point(class_scope:IBUS.ControlPointInf)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double accelerationcmd_;
  int gearcmd_;
  int throttleflagcmd_;
  double throttlecmd_;
  double brakecmd_;
  int brakeflagcmd_;
  int epbcmd_;
  double steeringcmd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DecisonInterface_2eproto;
};
// -------------------------------------------------------------------

class NavigationService :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IBUS.NavigationService) */ {
 public:
  NavigationService();
  virtual ~NavigationService();

  NavigationService(const NavigationService& from);
  NavigationService(NavigationService&& from) noexcept
    : NavigationService() {
    *this = ::std::move(from);
  }

  inline NavigationService& operator=(const NavigationService& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationService& operator=(NavigationService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NavigationService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NavigationService* internal_default_instance() {
    return reinterpret_cast<const NavigationService*>(
               &_NavigationService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(NavigationService& a, NavigationService& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigationService* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NavigationService* New() const final {
    return CreateMaybeMessage<NavigationService>(nullptr);
  }

  NavigationService* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NavigationService>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NavigationService& from);
  void MergeFrom(const NavigationService& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigationService* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IBUS.NavigationService";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_DecisonInterface_2eproto);
    return ::descriptor_table_DecisonInterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecommendRoadSegmentsFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kNavigationServiceFlgFieldNumber = 3,
  };
  // repeated .IBUS.Recommendation RecommendRoadSegments = 2;
  int recommendroadsegments_size() const;
  void clear_recommendroadsegments();
  ::IBUS::Recommendation* mutable_recommendroadsegments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::Recommendation >*
      mutable_recommendroadsegments();
  const ::IBUS::Recommendation& recommendroadsegments(int index) const;
  ::IBUS::Recommendation* add_recommendroadsegments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::Recommendation >&
      recommendroadsegments() const;

  // .IBUS.Header header = 1;
  bool has_header() const;
  void clear_header();
  const ::IBUS::Header& header() const;
  ::IBUS::Header* release_header();
  ::IBUS::Header* mutable_header();
  void set_allocated_header(::IBUS::Header* header);

  // uint32 NavigationServiceFlg = 3;
  void clear_navigationserviceflg();
  ::PROTOBUF_NAMESPACE_ID::uint32 navigationserviceflg() const;
  void set_navigationserviceflg(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:IBUS.NavigationService)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::Recommendation > recommendroadsegments_;
  ::IBUS::Header* header_;
  ::PROTOBUF_NAMESPACE_ID::uint32 navigationserviceflg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DecisonInterface_2eproto;
};
// -------------------------------------------------------------------

class DecisionService :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IBUS.DecisionService) */ {
 public:
  DecisionService();
  virtual ~DecisionService();

  DecisionService(const DecisionService& from);
  DecisionService(DecisionService&& from) noexcept
    : DecisionService() {
    *this = ::std::move(from);
  }

  inline DecisionService& operator=(const DecisionService& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecisionService& operator=(DecisionService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DecisionService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DecisionService* internal_default_instance() {
    return reinterpret_cast<const DecisionService*>(
               &_DecisionService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DecisionService& a, DecisionService& b) {
    a.Swap(&b);
  }
  inline void Swap(DecisionService* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DecisionService* New() const final {
    return CreateMaybeMessage<DecisionService>(nullptr);
  }

  DecisionService* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DecisionService>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DecisionService& from);
  void MergeFrom(const DecisionService& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecisionService* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IBUS.DecisionService";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_DecisonInterface_2eproto);
    return ::descriptor_table_DecisonInterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kMDecisionFieldNumber = 2,
    kDDecisionFieldNumber = 3,
    kDecisionServiceFlgFieldNumber = 4,
  };
  // .IBUS.Header header = 1;
  bool has_header() const;
  void clear_header();
  const ::IBUS::Header& header() const;
  ::IBUS::Header* release_header();
  ::IBUS::Header* mutable_header();
  void set_allocated_header(::IBUS::Header* header);

  // .IBUS.MissionDecision MDecision = 2;
  bool has_mdecision() const;
  void clear_mdecision();
  const ::IBUS::MissionDecision& mdecision() const;
  ::IBUS::MissionDecision* release_mdecision();
  ::IBUS::MissionDecision* mutable_mdecision();
  void set_allocated_mdecision(::IBUS::MissionDecision* mdecision);

  // .IBUS.DDTDecision DDecision = 3;
  bool has_ddecision() const;
  void clear_ddecision();
  const ::IBUS::DDTDecision& ddecision() const;
  ::IBUS::DDTDecision* release_ddecision();
  ::IBUS::DDTDecision* mutable_ddecision();
  void set_allocated_ddecision(::IBUS::DDTDecision* ddecision);

  // uint32 DecisionServiceFlg = 4;
  void clear_decisionserviceflg();
  ::PROTOBUF_NAMESPACE_ID::uint32 decisionserviceflg() const;
  void set_decisionserviceflg(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:IBUS.DecisionService)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::IBUS::Header* header_;
  ::IBUS::MissionDecision* mdecision_;
  ::IBUS::DDTDecision* ddecision_;
  ::PROTOBUF_NAMESPACE_ID::uint32 decisionserviceflg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DecisonInterface_2eproto;
};
// -------------------------------------------------------------------

class TrajectoryPlanningService :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IBUS.TrajectoryPlanningService) */ {
 public:
  TrajectoryPlanningService();
  virtual ~TrajectoryPlanningService();

  TrajectoryPlanningService(const TrajectoryPlanningService& from);
  TrajectoryPlanningService(TrajectoryPlanningService&& from) noexcept
    : TrajectoryPlanningService() {
    *this = ::std::move(from);
  }

  inline TrajectoryPlanningService& operator=(const TrajectoryPlanningService& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrajectoryPlanningService& operator=(TrajectoryPlanningService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrajectoryPlanningService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrajectoryPlanningService* internal_default_instance() {
    return reinterpret_cast<const TrajectoryPlanningService*>(
               &_TrajectoryPlanningService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TrajectoryPlanningService& a, TrajectoryPlanningService& b) {
    a.Swap(&b);
  }
  inline void Swap(TrajectoryPlanningService* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrajectoryPlanningService* New() const final {
    return CreateMaybeMessage<TrajectoryPlanningService>(nullptr);
  }

  TrajectoryPlanningService* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrajectoryPlanningService>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrajectoryPlanningService& from);
  void MergeFrom(const TrajectoryPlanningService& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrajectoryPlanningService* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IBUS.TrajectoryPlanningService";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_DecisonInterface_2eproto);
    return ::descriptor_table_DecisonInterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrajectoryPointsFieldNumber = 5,
    kLatMaxOffsetFieldNumber = 6,
    kRefLineFieldNumber = 7,
    kPathBoundFieldNumber = 8,
    kHeaderFieldNumber = 1,
    kDebugPointFieldNumber = 9,
    kControlPointFieldNumber = 10,
    kTrajectoryLengthFieldNumber = 3,
    kTrajectoryTimeFieldNumber = 4,
    kTrajTypeFieldNumber = 2,
    kTrajectoryPlanningServiceFlgFieldNumber = 11,
  };
  // repeated .IBUS.TrajectoryPoint TrajectoryPoints = 5;
  int trajectorypoints_size() const;
  void clear_trajectorypoints();
  ::IBUS::TrajectoryPoint* mutable_trajectorypoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::TrajectoryPoint >*
      mutable_trajectorypoints();
  const ::IBUS::TrajectoryPoint& trajectorypoints(int index) const;
  ::IBUS::TrajectoryPoint* add_trajectorypoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::TrajectoryPoint >&
      trajectorypoints() const;

  // repeated double LatMaxOffset = 6;
  int latmaxoffset_size() const;
  void clear_latmaxoffset();
  double latmaxoffset(int index) const;
  void set_latmaxoffset(int index, double value);
  void add_latmaxoffset(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      latmaxoffset() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_latmaxoffset();

  // repeated .IBUS.RefLinePoint RefLine = 7;
  int refline_size() const;
  void clear_refline();
  ::IBUS::RefLinePoint* mutable_refline(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::RefLinePoint >*
      mutable_refline();
  const ::IBUS::RefLinePoint& refline(int index) const;
  ::IBUS::RefLinePoint* add_refline();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::RefLinePoint >&
      refline() const;

  // repeated .IBUS.PathBoundPoint PathBound = 8;
  int pathbound_size() const;
  void clear_pathbound();
  ::IBUS::PathBoundPoint* mutable_pathbound(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::PathBoundPoint >*
      mutable_pathbound();
  const ::IBUS::PathBoundPoint& pathbound(int index) const;
  ::IBUS::PathBoundPoint* add_pathbound();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::PathBoundPoint >&
      pathbound() const;

  // .IBUS.Header header = 1;
  bool has_header() const;
  void clear_header();
  const ::IBUS::Header& header() const;
  ::IBUS::Header* release_header();
  ::IBUS::Header* mutable_header();
  void set_allocated_header(::IBUS::Header* header);

  // .IBUS.DebugPointInf DebugPoint = 9;
  bool has_debugpoint() const;
  void clear_debugpoint();
  const ::IBUS::DebugPointInf& debugpoint() const;
  ::IBUS::DebugPointInf* release_debugpoint();
  ::IBUS::DebugPointInf* mutable_debugpoint();
  void set_allocated_debugpoint(::IBUS::DebugPointInf* debugpoint);

  // .IBUS.ControlPointInf ControlPoint = 10;
  bool has_controlpoint() const;
  void clear_controlpoint();
  const ::IBUS::ControlPointInf& controlpoint() const;
  ::IBUS::ControlPointInf* release_controlpoint();
  ::IBUS::ControlPointInf* mutable_controlpoint();
  void set_allocated_controlpoint(::IBUS::ControlPointInf* controlpoint);

  // double TrajectoryLength = 3;
  void clear_trajectorylength();
  double trajectorylength() const;
  void set_trajectorylength(double value);

  // double TrajectoryTime = 4;
  void clear_trajectorytime();
  double trajectorytime() const;
  void set_trajectorytime(double value);

  // .IBUS.TrajectoryType TrajType = 2;
  void clear_trajtype();
  ::IBUS::TrajectoryType trajtype() const;
  void set_trajtype(::IBUS::TrajectoryType value);

  // uint32 TrajectoryPlanningServiceFlg = 11;
  void clear_trajectoryplanningserviceflg();
  ::PROTOBUF_NAMESPACE_ID::uint32 trajectoryplanningserviceflg() const;
  void set_trajectoryplanningserviceflg(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:IBUS.TrajectoryPlanningService)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::TrajectoryPoint > trajectorypoints_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > latmaxoffset_;
  mutable std::atomic<int> _latmaxoffset_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::RefLinePoint > refline_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::PathBoundPoint > pathbound_;
  ::IBUS::Header* header_;
  ::IBUS::DebugPointInf* debugpoint_;
  ::IBUS::ControlPointInf* controlpoint_;
  double trajectorylength_;
  double trajectorytime_;
  int trajtype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 trajectoryplanningserviceflg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DecisonInterface_2eproto;
};
// -------------------------------------------------------------------

class DecisionPlanMsg :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IBUS.DecisionPlanMsg) */ {
 public:
  DecisionPlanMsg();
  virtual ~DecisionPlanMsg();

  DecisionPlanMsg(const DecisionPlanMsg& from);
  DecisionPlanMsg(DecisionPlanMsg&& from) noexcept
    : DecisionPlanMsg() {
    *this = ::std::move(from);
  }

  inline DecisionPlanMsg& operator=(const DecisionPlanMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecisionPlanMsg& operator=(DecisionPlanMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DecisionPlanMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DecisionPlanMsg* internal_default_instance() {
    return reinterpret_cast<const DecisionPlanMsg*>(
               &_DecisionPlanMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DecisionPlanMsg& a, DecisionPlanMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(DecisionPlanMsg* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DecisionPlanMsg* New() const final {
    return CreateMaybeMessage<DecisionPlanMsg>(nullptr);
  }

  DecisionPlanMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DecisionPlanMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DecisionPlanMsg& from);
  void MergeFrom(const DecisionPlanMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecisionPlanMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IBUS.DecisionPlanMsg";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_DecisonInterface_2eproto);
    return ::descriptor_table_DecisonInterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNavigationInterfaceFieldNumber = 1,
    kDecisionInterfaceFieldNumber = 2,
    kTrajectoryPlanningInterfaceFieldNumber = 3,
  };
  // .IBUS.NavigationService NavigationInterface = 1;
  bool has_navigationinterface() const;
  void clear_navigationinterface();
  const ::IBUS::NavigationService& navigationinterface() const;
  ::IBUS::NavigationService* release_navigationinterface();
  ::IBUS::NavigationService* mutable_navigationinterface();
  void set_allocated_navigationinterface(::IBUS::NavigationService* navigationinterface);

  // .IBUS.DecisionService DecisionInterface = 2;
  bool has_decisioninterface() const;
  void clear_decisioninterface();
  const ::IBUS::DecisionService& decisioninterface() const;
  ::IBUS::DecisionService* release_decisioninterface();
  ::IBUS::DecisionService* mutable_decisioninterface();
  void set_allocated_decisioninterface(::IBUS::DecisionService* decisioninterface);

  // .IBUS.TrajectoryPlanningService TrajectoryPlanningInterface = 3;
  bool has_trajectoryplanninginterface() const;
  void clear_trajectoryplanninginterface();
  const ::IBUS::TrajectoryPlanningService& trajectoryplanninginterface() const;
  ::IBUS::TrajectoryPlanningService* release_trajectoryplanninginterface();
  ::IBUS::TrajectoryPlanningService* mutable_trajectoryplanninginterface();
  void set_allocated_trajectoryplanninginterface(::IBUS::TrajectoryPlanningService* trajectoryplanninginterface);

  // @@protoc_insertion_point(class_scope:IBUS.DecisionPlanMsg)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::IBUS::NavigationService* navigationinterface_;
  ::IBUS::DecisionService* decisioninterface_;
  ::IBUS::TrajectoryPlanningService* trajectoryplanninginterface_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_DecisonInterface_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Recommendation

// uint64 CurrentSequenceIDs = 1;
inline void Recommendation::clear_currentsequenceids() {
  currentsequenceids_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Recommendation::currentsequenceids() const {
  // @@protoc_insertion_point(field_get:IBUS.Recommendation.CurrentSequenceIDs)
  return currentsequenceids_;
}
inline void Recommendation::set_currentsequenceids(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  currentsequenceids_ = value;
  // @@protoc_insertion_point(field_set:IBUS.Recommendation.CurrentSequenceIDs)
}

// uint64 TargetSequeceIDs = 2;
inline void Recommendation::clear_targetsequeceids() {
  targetsequeceids_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Recommendation::targetsequeceids() const {
  // @@protoc_insertion_point(field_get:IBUS.Recommendation.TargetSequeceIDs)
  return targetsequeceids_;
}
inline void Recommendation::set_targetsequeceids(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  targetsequeceids_ = value;
  // @@protoc_insertion_point(field_set:IBUS.Recommendation.TargetSequeceIDs)
}

// uint32 SpeedLimits = 3;
inline void Recommendation::clear_speedlimits() {
  speedlimits_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Recommendation::speedlimits() const {
  // @@protoc_insertion_point(field_get:IBUS.Recommendation.SpeedLimits)
  return speedlimits_;
}
inline void Recommendation::set_speedlimits(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  speedlimits_ = value;
  // @@protoc_insertion_point(field_set:IBUS.Recommendation.SpeedLimits)
}

// -------------------------------------------------------------------

// MissionDecision

// .IBUS.MissionDecision.MissionType type = 1;
inline void MissionDecision::clear_type() {
  type_ = 0;
}
inline ::IBUS::MissionDecision_MissionType MissionDecision::type() const {
  // @@protoc_insertion_point(field_get:IBUS.MissionDecision.type)
  return static_cast< ::IBUS::MissionDecision_MissionType >(type_);
}
inline void MissionDecision::set_type(::IBUS::MissionDecision_MissionType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:IBUS.MissionDecision.type)
}

// uint32 LaneAttached = 2;
inline void MissionDecision::clear_laneattached() {
  laneattached_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MissionDecision::laneattached() const {
  // @@protoc_insertion_point(field_get:IBUS.MissionDecision.LaneAttached)
  return laneattached_;
}
inline void MissionDecision::set_laneattached(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  laneattached_ = value;
  // @@protoc_insertion_point(field_set:IBUS.MissionDecision.LaneAttached)
}

// uint32 ParkingLotsAttached = 3;
inline void MissionDecision::clear_parkinglotsattached() {
  parkinglotsattached_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MissionDecision::parkinglotsattached() const {
  // @@protoc_insertion_point(field_get:IBUS.MissionDecision.ParkingLotsAttached)
  return parkinglotsattached_;
}
inline void MissionDecision::set_parkinglotsattached(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  parkinglotsattached_ = value;
  // @@protoc_insertion_point(field_set:IBUS.MissionDecision.ParkingLotsAttached)
}

// double HeadingAttached = 4;
inline void MissionDecision::clear_headingattached() {
  headingattached_ = 0;
}
inline double MissionDecision::headingattached() const {
  // @@protoc_insertion_point(field_get:IBUS.MissionDecision.HeadingAttached)
  return headingattached_;
}
inline void MissionDecision::set_headingattached(double value) {
  
  headingattached_ = value;
  // @@protoc_insertion_point(field_set:IBUS.MissionDecision.HeadingAttached)
}

// .IBUS.MissionDecision.StatusMDecision StatusAttached = 5;
inline void MissionDecision::clear_statusattached() {
  statusattached_ = 0;
}
inline ::IBUS::MissionDecision_StatusMDecision MissionDecision::statusattached() const {
  // @@protoc_insertion_point(field_get:IBUS.MissionDecision.StatusAttached)
  return static_cast< ::IBUS::MissionDecision_StatusMDecision >(statusattached_);
}
inline void MissionDecision::set_statusattached(::IBUS::MissionDecision_StatusMDecision value) {
  
  statusattached_ = value;
  // @@protoc_insertion_point(field_set:IBUS.MissionDecision.StatusAttached)
}

// .IBUS.Point2D ParkingPoint = 6;
inline bool MissionDecision::has_parkingpoint() const {
  return this != internal_default_instance() && parkingpoint_ != nullptr;
}
inline const ::IBUS::Point2D& MissionDecision::parkingpoint() const {
  const ::IBUS::Point2D* p = parkingpoint_;
  // @@protoc_insertion_point(field_get:IBUS.MissionDecision.ParkingPoint)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::Point2D*>(
      &::IBUS::_Point2D_default_instance_);
}
inline ::IBUS::Point2D* MissionDecision::release_parkingpoint() {
  // @@protoc_insertion_point(field_release:IBUS.MissionDecision.ParkingPoint)
  
  ::IBUS::Point2D* temp = parkingpoint_;
  parkingpoint_ = nullptr;
  return temp;
}
inline ::IBUS::Point2D* MissionDecision::mutable_parkingpoint() {
  
  if (parkingpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::Point2D>(GetArenaNoVirtual());
    parkingpoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.MissionDecision.ParkingPoint)
  return parkingpoint_;
}
inline void MissionDecision::set_allocated_parkingpoint(::IBUS::Point2D* parkingpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(parkingpoint_);
  }
  if (parkingpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      parkingpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parkingpoint, submessage_arena);
    }
    
  } else {
    
  }
  parkingpoint_ = parkingpoint;
  // @@protoc_insertion_point(field_set_allocated:IBUS.MissionDecision.ParkingPoint)
}

// -------------------------------------------------------------------

// DDTDecision_ObjectDecision

// uint32 ObjectID = 1;
inline void DDTDecision_ObjectDecision::clear_objectid() {
  objectid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DDTDecision_ObjectDecision::objectid() const {
  // @@protoc_insertion_point(field_get:IBUS.DDTDecision.ObjectDecision.ObjectID)
  return objectid_;
}
inline void DDTDecision_ObjectDecision::set_objectid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  objectid_ = value;
  // @@protoc_insertion_point(field_set:IBUS.DDTDecision.ObjectDecision.ObjectID)
}

// .IBUS.DDTDecision.ObjectDecision.type ObjectDType = 2;
inline void DDTDecision_ObjectDecision::clear_objectdtype() {
  objectdtype_ = 0;
}
inline ::IBUS::DDTDecision_ObjectDecision_type DDTDecision_ObjectDecision::objectdtype() const {
  // @@protoc_insertion_point(field_get:IBUS.DDTDecision.ObjectDecision.ObjectDType)
  return static_cast< ::IBUS::DDTDecision_ObjectDecision_type >(objectdtype_);
}
inline void DDTDecision_ObjectDecision::set_objectdtype(::IBUS::DDTDecision_ObjectDecision_type value) {
  
  objectdtype_ = value;
  // @@protoc_insertion_point(field_set:IBUS.DDTDecision.ObjectDecision.ObjectDType)
}

// double HeadingAttached = 3;
inline void DDTDecision_ObjectDecision::clear_headingattached() {
  headingattached_ = 0;
}
inline double DDTDecision_ObjectDecision::headingattached() const {
  // @@protoc_insertion_point(field_get:IBUS.DDTDecision.ObjectDecision.HeadingAttached)
  return headingattached_;
}
inline void DDTDecision_ObjectDecision::set_headingattached(double value) {
  
  headingattached_ = value;
  // @@protoc_insertion_point(field_set:IBUS.DDTDecision.ObjectDecision.HeadingAttached)
}

// .IBUS.DDTDecision.ObjectDecision.DDTState StatusAttached = 4;
inline void DDTDecision_ObjectDecision::clear_statusattached() {
  statusattached_ = 0;
}
inline ::IBUS::DDTDecision_ObjectDecision_DDTState DDTDecision_ObjectDecision::statusattached() const {
  // @@protoc_insertion_point(field_get:IBUS.DDTDecision.ObjectDecision.StatusAttached)
  return static_cast< ::IBUS::DDTDecision_ObjectDecision_DDTState >(statusattached_);
}
inline void DDTDecision_ObjectDecision::set_statusattached(::IBUS::DDTDecision_ObjectDecision_DDTState value) {
  
  statusattached_ = value;
  // @@protoc_insertion_point(field_set:IBUS.DDTDecision.ObjectDecision.StatusAttached)
}

// double SafetLateralDistance = 5;
inline void DDTDecision_ObjectDecision::clear_safetlateraldistance() {
  safetlateraldistance_ = 0;
}
inline double DDTDecision_ObjectDecision::safetlateraldistance() const {
  // @@protoc_insertion_point(field_get:IBUS.DDTDecision.ObjectDecision.SafetLateralDistance)
  return safetlateraldistance_;
}
inline void DDTDecision_ObjectDecision::set_safetlateraldistance(double value) {
  
  safetlateraldistance_ = value;
  // @@protoc_insertion_point(field_set:IBUS.DDTDecision.ObjectDecision.SafetLateralDistance)
}

// double SafetyLongitudinalDistance = 6;
inline void DDTDecision_ObjectDecision::clear_safetylongitudinaldistance() {
  safetylongitudinaldistance_ = 0;
}
inline double DDTDecision_ObjectDecision::safetylongitudinaldistance() const {
  // @@protoc_insertion_point(field_get:IBUS.DDTDecision.ObjectDecision.SafetyLongitudinalDistance)
  return safetylongitudinaldistance_;
}
inline void DDTDecision_ObjectDecision::set_safetylongitudinaldistance(double value) {
  
  safetylongitudinaldistance_ = value;
  // @@protoc_insertion_point(field_set:IBUS.DDTDecision.ObjectDecision.SafetyLongitudinalDistance)
}

// -------------------------------------------------------------------

// DDTDecision

// repeated .IBUS.DDTDecision.ObjectDecision ObjectsDecisions = 1;
inline int DDTDecision::objectsdecisions_size() const {
  return objectsdecisions_.size();
}
inline void DDTDecision::clear_objectsdecisions() {
  objectsdecisions_.Clear();
}
inline ::IBUS::DDTDecision_ObjectDecision* DDTDecision::mutable_objectsdecisions(int index) {
  // @@protoc_insertion_point(field_mutable:IBUS.DDTDecision.ObjectsDecisions)
  return objectsdecisions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::DDTDecision_ObjectDecision >*
DDTDecision::mutable_objectsdecisions() {
  // @@protoc_insertion_point(field_mutable_list:IBUS.DDTDecision.ObjectsDecisions)
  return &objectsdecisions_;
}
inline const ::IBUS::DDTDecision_ObjectDecision& DDTDecision::objectsdecisions(int index) const {
  // @@protoc_insertion_point(field_get:IBUS.DDTDecision.ObjectsDecisions)
  return objectsdecisions_.Get(index);
}
inline ::IBUS::DDTDecision_ObjectDecision* DDTDecision::add_objectsdecisions() {
  // @@protoc_insertion_point(field_add:IBUS.DDTDecision.ObjectsDecisions)
  return objectsdecisions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::DDTDecision_ObjectDecision >&
DDTDecision::objectsdecisions() const {
  // @@protoc_insertion_point(field_list:IBUS.DDTDecision.ObjectsDecisions)
  return objectsdecisions_;
}

// -------------------------------------------------------------------

// TrajectoryPoint

// .IBUS.Point3D position = 1;
inline bool TrajectoryPoint::has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline const ::IBUS::Point3D& TrajectoryPoint::position() const {
  const ::IBUS::Point3D* p = position_;
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPoint.position)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::Point3D*>(
      &::IBUS::_Point3D_default_instance_);
}
inline ::IBUS::Point3D* TrajectoryPoint::release_position() {
  // @@protoc_insertion_point(field_release:IBUS.TrajectoryPoint.position)
  
  ::IBUS::Point3D* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::IBUS::Point3D* TrajectoryPoint::mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::Point3D>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.TrajectoryPoint.position)
  return position_;
}
inline void TrajectoryPoint::set_allocated_position(::IBUS::Point3D* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:IBUS.TrajectoryPoint.position)
}

// double theta = 2;
inline void TrajectoryPoint::clear_theta() {
  theta_ = 0;
}
inline double TrajectoryPoint::theta() const {
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPoint.theta)
  return theta_;
}
inline void TrajectoryPoint::set_theta(double value) {
  
  theta_ = value;
  // @@protoc_insertion_point(field_set:IBUS.TrajectoryPoint.theta)
}

// double kappa = 3;
inline void TrajectoryPoint::clear_kappa() {
  kappa_ = 0;
}
inline double TrajectoryPoint::kappa() const {
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPoint.kappa)
  return kappa_;
}
inline void TrajectoryPoint::set_kappa(double value) {
  
  kappa_ = value;
  // @@protoc_insertion_point(field_set:IBUS.TrajectoryPoint.kappa)
}

// uint32 laneID = 4;
inline void TrajectoryPoint::clear_laneid() {
  laneid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TrajectoryPoint::laneid() const {
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPoint.laneID)
  return laneid_;
}
inline void TrajectoryPoint::set_laneid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  laneid_ = value;
  // @@protoc_insertion_point(field_set:IBUS.TrajectoryPoint.laneID)
}

// double TimeRelativeToStart = 5;
inline void TrajectoryPoint::clear_timerelativetostart() {
  timerelativetostart_ = 0;
}
inline double TrajectoryPoint::timerelativetostart() const {
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPoint.TimeRelativeToStart)
  return timerelativetostart_;
}
inline void TrajectoryPoint::set_timerelativetostart(double value) {
  
  timerelativetostart_ = value;
  // @@protoc_insertion_point(field_set:IBUS.TrajectoryPoint.TimeRelativeToStart)
}

// double Heading = 6;
inline void TrajectoryPoint::clear_heading() {
  heading_ = 0;
}
inline double TrajectoryPoint::heading() const {
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPoint.Heading)
  return heading_;
}
inline void TrajectoryPoint::set_heading(double value) {
  
  heading_ = value;
  // @@protoc_insertion_point(field_set:IBUS.TrajectoryPoint.Heading)
}

// double Speed = 7;
inline void TrajectoryPoint::clear_speed() {
  speed_ = 0;
}
inline double TrajectoryPoint::speed() const {
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPoint.Speed)
  return speed_;
}
inline void TrajectoryPoint::set_speed(double value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:IBUS.TrajectoryPoint.Speed)
}

// double Accel = 8;
inline void TrajectoryPoint::clear_accel() {
  accel_ = 0;
}
inline double TrajectoryPoint::accel() const {
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPoint.Accel)
  return accel_;
}
inline void TrajectoryPoint::set_accel(double value) {
  
  accel_ = value;
  // @@protoc_insertion_point(field_set:IBUS.TrajectoryPoint.Accel)
}

// double grade = 9;
inline void TrajectoryPoint::clear_grade() {
  grade_ = 0;
}
inline double TrajectoryPoint::grade() const {
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPoint.grade)
  return grade_;
}
inline void TrajectoryPoint::set_grade(double value) {
  
  grade_ = value;
  // @@protoc_insertion_point(field_set:IBUS.TrajectoryPoint.grade)
}

// double s = 10;
inline void TrajectoryPoint::clear_s() {
  s_ = 0;
}
inline double TrajectoryPoint::s() const {
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPoint.s)
  return s_;
}
inline void TrajectoryPoint::set_s(double value) {
  
  s_ = value;
  // @@protoc_insertion_point(field_set:IBUS.TrajectoryPoint.s)
}

// double steer = 11;
inline void TrajectoryPoint::clear_steer() {
  steer_ = 0;
}
inline double TrajectoryPoint::steer() const {
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPoint.steer)
  return steer_;
}
inline void TrajectoryPoint::set_steer(double value) {
  
  steer_ = value;
  // @@protoc_insertion_point(field_set:IBUS.TrajectoryPoint.steer)
}

// -------------------------------------------------------------------

// RefLinePoint

// double s = 1;
inline void RefLinePoint::clear_s() {
  s_ = 0;
}
inline double RefLinePoint::s() const {
  // @@protoc_insertion_point(field_get:IBUS.RefLinePoint.s)
  return s_;
}
inline void RefLinePoint::set_s(double value) {
  
  s_ = value;
  // @@protoc_insertion_point(field_set:IBUS.RefLinePoint.s)
}

// double l = 2;
inline void RefLinePoint::clear_l() {
  l_ = 0;
}
inline double RefLinePoint::l() const {
  // @@protoc_insertion_point(field_get:IBUS.RefLinePoint.l)
  return l_;
}
inline void RefLinePoint::set_l(double value) {
  
  l_ = value;
  // @@protoc_insertion_point(field_set:IBUS.RefLinePoint.l)
}

// .IBUS.Point3D point = 3;
inline bool RefLinePoint::has_point() const {
  return this != internal_default_instance() && point_ != nullptr;
}
inline const ::IBUS::Point3D& RefLinePoint::point() const {
  const ::IBUS::Point3D* p = point_;
  // @@protoc_insertion_point(field_get:IBUS.RefLinePoint.point)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::Point3D*>(
      &::IBUS::_Point3D_default_instance_);
}
inline ::IBUS::Point3D* RefLinePoint::release_point() {
  // @@protoc_insertion_point(field_release:IBUS.RefLinePoint.point)
  
  ::IBUS::Point3D* temp = point_;
  point_ = nullptr;
  return temp;
}
inline ::IBUS::Point3D* RefLinePoint::mutable_point() {
  
  if (point_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::Point3D>(GetArenaNoVirtual());
    point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.RefLinePoint.point)
  return point_;
}
inline void RefLinePoint::set_allocated_point(::IBUS::Point3D* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_);
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:IBUS.RefLinePoint.point)
}

// double theta = 4;
inline void RefLinePoint::clear_theta() {
  theta_ = 0;
}
inline double RefLinePoint::theta() const {
  // @@protoc_insertion_point(field_get:IBUS.RefLinePoint.theta)
  return theta_;
}
inline void RefLinePoint::set_theta(double value) {
  
  theta_ = value;
  // @@protoc_insertion_point(field_set:IBUS.RefLinePoint.theta)
}

// double kappa = 5;
inline void RefLinePoint::clear_kappa() {
  kappa_ = 0;
}
inline double RefLinePoint::kappa() const {
  // @@protoc_insertion_point(field_get:IBUS.RefLinePoint.kappa)
  return kappa_;
}
inline void RefLinePoint::set_kappa(double value) {
  
  kappa_ = value;
  // @@protoc_insertion_point(field_set:IBUS.RefLinePoint.kappa)
}

// double grade = 6;
inline void RefLinePoint::clear_grade() {
  grade_ = 0;
}
inline double RefLinePoint::grade() const {
  // @@protoc_insertion_point(field_get:IBUS.RefLinePoint.grade)
  return grade_;
}
inline void RefLinePoint::set_grade(double value) {
  
  grade_ = value;
  // @@protoc_insertion_point(field_set:IBUS.RefLinePoint.grade)
}

// double width = 7;
inline void RefLinePoint::clear_width() {
  width_ = 0;
}
inline double RefLinePoint::width() const {
  // @@protoc_insertion_point(field_get:IBUS.RefLinePoint.width)
  return width_;
}
inline void RefLinePoint::set_width(double value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:IBUS.RefLinePoint.width)
}

// double laneid = 8;
inline void RefLinePoint::clear_laneid() {
  laneid_ = 0;
}
inline double RefLinePoint::laneid() const {
  // @@protoc_insertion_point(field_get:IBUS.RefLinePoint.laneid)
  return laneid_;
}
inline void RefLinePoint::set_laneid(double value) {
  
  laneid_ = value;
  // @@protoc_insertion_point(field_set:IBUS.RefLinePoint.laneid)
}

// -------------------------------------------------------------------

// PathBoundPoint

// .IBUS.Point2D PathBoundL = 1;
inline bool PathBoundPoint::has_pathboundl() const {
  return this != internal_default_instance() && pathboundl_ != nullptr;
}
inline const ::IBUS::Point2D& PathBoundPoint::pathboundl() const {
  const ::IBUS::Point2D* p = pathboundl_;
  // @@protoc_insertion_point(field_get:IBUS.PathBoundPoint.PathBoundL)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::Point2D*>(
      &::IBUS::_Point2D_default_instance_);
}
inline ::IBUS::Point2D* PathBoundPoint::release_pathboundl() {
  // @@protoc_insertion_point(field_release:IBUS.PathBoundPoint.PathBoundL)
  
  ::IBUS::Point2D* temp = pathboundl_;
  pathboundl_ = nullptr;
  return temp;
}
inline ::IBUS::Point2D* PathBoundPoint::mutable_pathboundl() {
  
  if (pathboundl_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::Point2D>(GetArenaNoVirtual());
    pathboundl_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.PathBoundPoint.PathBoundL)
  return pathboundl_;
}
inline void PathBoundPoint::set_allocated_pathboundl(::IBUS::Point2D* pathboundl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathboundl_);
  }
  if (pathboundl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pathboundl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathboundl, submessage_arena);
    }
    
  } else {
    
  }
  pathboundl_ = pathboundl;
  // @@protoc_insertion_point(field_set_allocated:IBUS.PathBoundPoint.PathBoundL)
}

// .IBUS.Point2D PathBoundR = 2;
inline bool PathBoundPoint::has_pathboundr() const {
  return this != internal_default_instance() && pathboundr_ != nullptr;
}
inline const ::IBUS::Point2D& PathBoundPoint::pathboundr() const {
  const ::IBUS::Point2D* p = pathboundr_;
  // @@protoc_insertion_point(field_get:IBUS.PathBoundPoint.PathBoundR)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::Point2D*>(
      &::IBUS::_Point2D_default_instance_);
}
inline ::IBUS::Point2D* PathBoundPoint::release_pathboundr() {
  // @@protoc_insertion_point(field_release:IBUS.PathBoundPoint.PathBoundR)
  
  ::IBUS::Point2D* temp = pathboundr_;
  pathboundr_ = nullptr;
  return temp;
}
inline ::IBUS::Point2D* PathBoundPoint::mutable_pathboundr() {
  
  if (pathboundr_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::Point2D>(GetArenaNoVirtual());
    pathboundr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.PathBoundPoint.PathBoundR)
  return pathboundr_;
}
inline void PathBoundPoint::set_allocated_pathboundr(::IBUS::Point2D* pathboundr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathboundr_);
  }
  if (pathboundr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pathboundr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathboundr, submessage_arena);
    }
    
  } else {
    
  }
  pathboundr_ = pathboundr;
  // @@protoc_insertion_point(field_set_allocated:IBUS.PathBoundPoint.PathBoundR)
}

// .IBUS.Point2D LaneBoundL = 3;
inline bool PathBoundPoint::has_laneboundl() const {
  return this != internal_default_instance() && laneboundl_ != nullptr;
}
inline const ::IBUS::Point2D& PathBoundPoint::laneboundl() const {
  const ::IBUS::Point2D* p = laneboundl_;
  // @@protoc_insertion_point(field_get:IBUS.PathBoundPoint.LaneBoundL)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::Point2D*>(
      &::IBUS::_Point2D_default_instance_);
}
inline ::IBUS::Point2D* PathBoundPoint::release_laneboundl() {
  // @@protoc_insertion_point(field_release:IBUS.PathBoundPoint.LaneBoundL)
  
  ::IBUS::Point2D* temp = laneboundl_;
  laneboundl_ = nullptr;
  return temp;
}
inline ::IBUS::Point2D* PathBoundPoint::mutable_laneboundl() {
  
  if (laneboundl_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::Point2D>(GetArenaNoVirtual());
    laneboundl_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.PathBoundPoint.LaneBoundL)
  return laneboundl_;
}
inline void PathBoundPoint::set_allocated_laneboundl(::IBUS::Point2D* laneboundl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(laneboundl_);
  }
  if (laneboundl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      laneboundl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, laneboundl, submessage_arena);
    }
    
  } else {
    
  }
  laneboundl_ = laneboundl;
  // @@protoc_insertion_point(field_set_allocated:IBUS.PathBoundPoint.LaneBoundL)
}

// .IBUS.Point2D LaneBoundR = 4;
inline bool PathBoundPoint::has_laneboundr() const {
  return this != internal_default_instance() && laneboundr_ != nullptr;
}
inline const ::IBUS::Point2D& PathBoundPoint::laneboundr() const {
  const ::IBUS::Point2D* p = laneboundr_;
  // @@protoc_insertion_point(field_get:IBUS.PathBoundPoint.LaneBoundR)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::Point2D*>(
      &::IBUS::_Point2D_default_instance_);
}
inline ::IBUS::Point2D* PathBoundPoint::release_laneboundr() {
  // @@protoc_insertion_point(field_release:IBUS.PathBoundPoint.LaneBoundR)
  
  ::IBUS::Point2D* temp = laneboundr_;
  laneboundr_ = nullptr;
  return temp;
}
inline ::IBUS::Point2D* PathBoundPoint::mutable_laneboundr() {
  
  if (laneboundr_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::Point2D>(GetArenaNoVirtual());
    laneboundr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.PathBoundPoint.LaneBoundR)
  return laneboundr_;
}
inline void PathBoundPoint::set_allocated_laneboundr(::IBUS::Point2D* laneboundr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(laneboundr_);
  }
  if (laneboundr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      laneboundr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, laneboundr, submessage_arena);
    }
    
  } else {
    
  }
  laneboundr_ = laneboundr;
  // @@protoc_insertion_point(field_set_allocated:IBUS.PathBoundPoint.LaneBoundR)
}

// -------------------------------------------------------------------

// DebugPointInf

// repeated .IBUS.Point2D DebugPoint = 1;
inline int DebugPointInf::debugpoint_size() const {
  return debugpoint_.size();
}
inline ::IBUS::Point2D* DebugPointInf::mutable_debugpoint(int index) {
  // @@protoc_insertion_point(field_mutable:IBUS.DebugPointInf.DebugPoint)
  return debugpoint_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::Point2D >*
DebugPointInf::mutable_debugpoint() {
  // @@protoc_insertion_point(field_mutable_list:IBUS.DebugPointInf.DebugPoint)
  return &debugpoint_;
}
inline const ::IBUS::Point2D& DebugPointInf::debugpoint(int index) const {
  // @@protoc_insertion_point(field_get:IBUS.DebugPointInf.DebugPoint)
  return debugpoint_.Get(index);
}
inline ::IBUS::Point2D* DebugPointInf::add_debugpoint() {
  // @@protoc_insertion_point(field_add:IBUS.DebugPointInf.DebugPoint)
  return debugpoint_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::Point2D >&
DebugPointInf::debugpoint() const {
  // @@protoc_insertion_point(field_list:IBUS.DebugPointInf.DebugPoint)
  return debugpoint_;
}

// .IBUS.DebugPointType PointType = 2;
inline void DebugPointInf::clear_pointtype() {
  pointtype_ = 0;
}
inline ::IBUS::DebugPointType DebugPointInf::pointtype() const {
  // @@protoc_insertion_point(field_get:IBUS.DebugPointInf.PointType)
  return static_cast< ::IBUS::DebugPointType >(pointtype_);
}
inline void DebugPointInf::set_pointtype(::IBUS::DebugPointType value) {
  
  pointtype_ = value;
  // @@protoc_insertion_point(field_set:IBUS.DebugPointInf.PointType)
}

// string PointLabel = 3;
inline void DebugPointInf::clear_pointlabel() {
  pointlabel_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DebugPointInf::pointlabel() const {
  // @@protoc_insertion_point(field_get:IBUS.DebugPointInf.PointLabel)
  return pointlabel_.GetNoArena();
}
inline void DebugPointInf::set_pointlabel(const std::string& value) {
  
  pointlabel_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IBUS.DebugPointInf.PointLabel)
}
inline void DebugPointInf::set_pointlabel(std::string&& value) {
  
  pointlabel_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IBUS.DebugPointInf.PointLabel)
}
inline void DebugPointInf::set_pointlabel(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  pointlabel_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IBUS.DebugPointInf.PointLabel)
}
inline void DebugPointInf::set_pointlabel(const char* value, size_t size) {
  
  pointlabel_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IBUS.DebugPointInf.PointLabel)
}
inline std::string* DebugPointInf::mutable_pointlabel() {
  
  // @@protoc_insertion_point(field_mutable:IBUS.DebugPointInf.PointLabel)
  return pointlabel_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DebugPointInf::release_pointlabel() {
  // @@protoc_insertion_point(field_release:IBUS.DebugPointInf.PointLabel)
  
  return pointlabel_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DebugPointInf::set_allocated_pointlabel(std::string* pointlabel) {
  if (pointlabel != nullptr) {
    
  } else {
    
  }
  pointlabel_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pointlabel);
  // @@protoc_insertion_point(field_set_allocated:IBUS.DebugPointInf.PointLabel)
}

// -------------------------------------------------------------------

// ControlPointInf

// .IBUS.GearType GearCmd = 1;
inline void ControlPointInf::clear_gearcmd() {
  gearcmd_ = 0;
}
inline ::IBUS::GearType ControlPointInf::gearcmd() const {
  // @@protoc_insertion_point(field_get:IBUS.ControlPointInf.GearCmd)
  return static_cast< ::IBUS::GearType >(gearcmd_);
}
inline void ControlPointInf::set_gearcmd(::IBUS::GearType value) {
  
  gearcmd_ = value;
  // @@protoc_insertion_point(field_set:IBUS.ControlPointInf.GearCmd)
}

// double AccelerationCmd = 2;
inline void ControlPointInf::clear_accelerationcmd() {
  accelerationcmd_ = 0;
}
inline double ControlPointInf::accelerationcmd() const {
  // @@protoc_insertion_point(field_get:IBUS.ControlPointInf.AccelerationCmd)
  return accelerationcmd_;
}
inline void ControlPointInf::set_accelerationcmd(double value) {
  
  accelerationcmd_ = value;
  // @@protoc_insertion_point(field_set:IBUS.ControlPointInf.AccelerationCmd)
}

// .IBUS.ThrottleFlagType ThrottleFlagCmd = 3;
inline void ControlPointInf::clear_throttleflagcmd() {
  throttleflagcmd_ = 0;
}
inline ::IBUS::ThrottleFlagType ControlPointInf::throttleflagcmd() const {
  // @@protoc_insertion_point(field_get:IBUS.ControlPointInf.ThrottleFlagCmd)
  return static_cast< ::IBUS::ThrottleFlagType >(throttleflagcmd_);
}
inline void ControlPointInf::set_throttleflagcmd(::IBUS::ThrottleFlagType value) {
  
  throttleflagcmd_ = value;
  // @@protoc_insertion_point(field_set:IBUS.ControlPointInf.ThrottleFlagCmd)
}

// double ThrottleCmd = 4;
inline void ControlPointInf::clear_throttlecmd() {
  throttlecmd_ = 0;
}
inline double ControlPointInf::throttlecmd() const {
  // @@protoc_insertion_point(field_get:IBUS.ControlPointInf.ThrottleCmd)
  return throttlecmd_;
}
inline void ControlPointInf::set_throttlecmd(double value) {
  
  throttlecmd_ = value;
  // @@protoc_insertion_point(field_set:IBUS.ControlPointInf.ThrottleCmd)
}

// .IBUS.BrakeFlagType BrakeFlagCmd = 5;
inline void ControlPointInf::clear_brakeflagcmd() {
  brakeflagcmd_ = 0;
}
inline ::IBUS::BrakeFlagType ControlPointInf::brakeflagcmd() const {
  // @@protoc_insertion_point(field_get:IBUS.ControlPointInf.BrakeFlagCmd)
  return static_cast< ::IBUS::BrakeFlagType >(brakeflagcmd_);
}
inline void ControlPointInf::set_brakeflagcmd(::IBUS::BrakeFlagType value) {
  
  brakeflagcmd_ = value;
  // @@protoc_insertion_point(field_set:IBUS.ControlPointInf.BrakeFlagCmd)
}

// double BrakeCmd = 6;
inline void ControlPointInf::clear_brakecmd() {
  brakecmd_ = 0;
}
inline double ControlPointInf::brakecmd() const {
  // @@protoc_insertion_point(field_get:IBUS.ControlPointInf.BrakeCmd)
  return brakecmd_;
}
inline void ControlPointInf::set_brakecmd(double value) {
  
  brakecmd_ = value;
  // @@protoc_insertion_point(field_set:IBUS.ControlPointInf.BrakeCmd)
}

// double SteeringCmd = 7;
inline void ControlPointInf::clear_steeringcmd() {
  steeringcmd_ = 0;
}
inline double ControlPointInf::steeringcmd() const {
  // @@protoc_insertion_point(field_get:IBUS.ControlPointInf.SteeringCmd)
  return steeringcmd_;
}
inline void ControlPointInf::set_steeringcmd(double value) {
  
  steeringcmd_ = value;
  // @@protoc_insertion_point(field_set:IBUS.ControlPointInf.SteeringCmd)
}

// .IBUS.EpbType EPBCmd = 8;
inline void ControlPointInf::clear_epbcmd() {
  epbcmd_ = 0;
}
inline ::IBUS::EpbType ControlPointInf::epbcmd() const {
  // @@protoc_insertion_point(field_get:IBUS.ControlPointInf.EPBCmd)
  return static_cast< ::IBUS::EpbType >(epbcmd_);
}
inline void ControlPointInf::set_epbcmd(::IBUS::EpbType value) {
  
  epbcmd_ = value;
  // @@protoc_insertion_point(field_set:IBUS.ControlPointInf.EPBCmd)
}

// -------------------------------------------------------------------

// NavigationService

// .IBUS.Header header = 1;
inline bool NavigationService::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline const ::IBUS::Header& NavigationService::header() const {
  const ::IBUS::Header* p = header_;
  // @@protoc_insertion_point(field_get:IBUS.NavigationService.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::Header*>(
      &::IBUS::_Header_default_instance_);
}
inline ::IBUS::Header* NavigationService::release_header() {
  // @@protoc_insertion_point(field_release:IBUS.NavigationService.header)
  
  ::IBUS::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::IBUS::Header* NavigationService::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.NavigationService.header)
  return header_;
}
inline void NavigationService::set_allocated_header(::IBUS::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:IBUS.NavigationService.header)
}

// repeated .IBUS.Recommendation RecommendRoadSegments = 2;
inline int NavigationService::recommendroadsegments_size() const {
  return recommendroadsegments_.size();
}
inline void NavigationService::clear_recommendroadsegments() {
  recommendroadsegments_.Clear();
}
inline ::IBUS::Recommendation* NavigationService::mutable_recommendroadsegments(int index) {
  // @@protoc_insertion_point(field_mutable:IBUS.NavigationService.RecommendRoadSegments)
  return recommendroadsegments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::Recommendation >*
NavigationService::mutable_recommendroadsegments() {
  // @@protoc_insertion_point(field_mutable_list:IBUS.NavigationService.RecommendRoadSegments)
  return &recommendroadsegments_;
}
inline const ::IBUS::Recommendation& NavigationService::recommendroadsegments(int index) const {
  // @@protoc_insertion_point(field_get:IBUS.NavigationService.RecommendRoadSegments)
  return recommendroadsegments_.Get(index);
}
inline ::IBUS::Recommendation* NavigationService::add_recommendroadsegments() {
  // @@protoc_insertion_point(field_add:IBUS.NavigationService.RecommendRoadSegments)
  return recommendroadsegments_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::Recommendation >&
NavigationService::recommendroadsegments() const {
  // @@protoc_insertion_point(field_list:IBUS.NavigationService.RecommendRoadSegments)
  return recommendroadsegments_;
}

// uint32 NavigationServiceFlg = 3;
inline void NavigationService::clear_navigationserviceflg() {
  navigationserviceflg_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NavigationService::navigationserviceflg() const {
  // @@protoc_insertion_point(field_get:IBUS.NavigationService.NavigationServiceFlg)
  return navigationserviceflg_;
}
inline void NavigationService::set_navigationserviceflg(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  navigationserviceflg_ = value;
  // @@protoc_insertion_point(field_set:IBUS.NavigationService.NavigationServiceFlg)
}

// -------------------------------------------------------------------

// DecisionService

// .IBUS.Header header = 1;
inline bool DecisionService::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline const ::IBUS::Header& DecisionService::header() const {
  const ::IBUS::Header* p = header_;
  // @@protoc_insertion_point(field_get:IBUS.DecisionService.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::Header*>(
      &::IBUS::_Header_default_instance_);
}
inline ::IBUS::Header* DecisionService::release_header() {
  // @@protoc_insertion_point(field_release:IBUS.DecisionService.header)
  
  ::IBUS::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::IBUS::Header* DecisionService::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.DecisionService.header)
  return header_;
}
inline void DecisionService::set_allocated_header(::IBUS::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:IBUS.DecisionService.header)
}

// .IBUS.MissionDecision MDecision = 2;
inline bool DecisionService::has_mdecision() const {
  return this != internal_default_instance() && mdecision_ != nullptr;
}
inline void DecisionService::clear_mdecision() {
  if (GetArenaNoVirtual() == nullptr && mdecision_ != nullptr) {
    delete mdecision_;
  }
  mdecision_ = nullptr;
}
inline const ::IBUS::MissionDecision& DecisionService::mdecision() const {
  const ::IBUS::MissionDecision* p = mdecision_;
  // @@protoc_insertion_point(field_get:IBUS.DecisionService.MDecision)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::MissionDecision*>(
      &::IBUS::_MissionDecision_default_instance_);
}
inline ::IBUS::MissionDecision* DecisionService::release_mdecision() {
  // @@protoc_insertion_point(field_release:IBUS.DecisionService.MDecision)
  
  ::IBUS::MissionDecision* temp = mdecision_;
  mdecision_ = nullptr;
  return temp;
}
inline ::IBUS::MissionDecision* DecisionService::mutable_mdecision() {
  
  if (mdecision_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::MissionDecision>(GetArenaNoVirtual());
    mdecision_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.DecisionService.MDecision)
  return mdecision_;
}
inline void DecisionService::set_allocated_mdecision(::IBUS::MissionDecision* mdecision) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete mdecision_;
  }
  if (mdecision) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      mdecision = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mdecision, submessage_arena);
    }
    
  } else {
    
  }
  mdecision_ = mdecision;
  // @@protoc_insertion_point(field_set_allocated:IBUS.DecisionService.MDecision)
}

// .IBUS.DDTDecision DDecision = 3;
inline bool DecisionService::has_ddecision() const {
  return this != internal_default_instance() && ddecision_ != nullptr;
}
inline void DecisionService::clear_ddecision() {
  if (GetArenaNoVirtual() == nullptr && ddecision_ != nullptr) {
    delete ddecision_;
  }
  ddecision_ = nullptr;
}
inline const ::IBUS::DDTDecision& DecisionService::ddecision() const {
  const ::IBUS::DDTDecision* p = ddecision_;
  // @@protoc_insertion_point(field_get:IBUS.DecisionService.DDecision)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::DDTDecision*>(
      &::IBUS::_DDTDecision_default_instance_);
}
inline ::IBUS::DDTDecision* DecisionService::release_ddecision() {
  // @@protoc_insertion_point(field_release:IBUS.DecisionService.DDecision)
  
  ::IBUS::DDTDecision* temp = ddecision_;
  ddecision_ = nullptr;
  return temp;
}
inline ::IBUS::DDTDecision* DecisionService::mutable_ddecision() {
  
  if (ddecision_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::DDTDecision>(GetArenaNoVirtual());
    ddecision_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.DecisionService.DDecision)
  return ddecision_;
}
inline void DecisionService::set_allocated_ddecision(::IBUS::DDTDecision* ddecision) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ddecision_;
  }
  if (ddecision) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ddecision = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ddecision, submessage_arena);
    }
    
  } else {
    
  }
  ddecision_ = ddecision;
  // @@protoc_insertion_point(field_set_allocated:IBUS.DecisionService.DDecision)
}

// uint32 DecisionServiceFlg = 4;
inline void DecisionService::clear_decisionserviceflg() {
  decisionserviceflg_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DecisionService::decisionserviceflg() const {
  // @@protoc_insertion_point(field_get:IBUS.DecisionService.DecisionServiceFlg)
  return decisionserviceflg_;
}
inline void DecisionService::set_decisionserviceflg(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  decisionserviceflg_ = value;
  // @@protoc_insertion_point(field_set:IBUS.DecisionService.DecisionServiceFlg)
}

// -------------------------------------------------------------------

// TrajectoryPlanningService

// .IBUS.Header header = 1;
inline bool TrajectoryPlanningService::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline const ::IBUS::Header& TrajectoryPlanningService::header() const {
  const ::IBUS::Header* p = header_;
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPlanningService.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::Header*>(
      &::IBUS::_Header_default_instance_);
}
inline ::IBUS::Header* TrajectoryPlanningService::release_header() {
  // @@protoc_insertion_point(field_release:IBUS.TrajectoryPlanningService.header)
  
  ::IBUS::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::IBUS::Header* TrajectoryPlanningService::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.TrajectoryPlanningService.header)
  return header_;
}
inline void TrajectoryPlanningService::set_allocated_header(::IBUS::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:IBUS.TrajectoryPlanningService.header)
}

// .IBUS.TrajectoryType TrajType = 2;
inline void TrajectoryPlanningService::clear_trajtype() {
  trajtype_ = 0;
}
inline ::IBUS::TrajectoryType TrajectoryPlanningService::trajtype() const {
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPlanningService.TrajType)
  return static_cast< ::IBUS::TrajectoryType >(trajtype_);
}
inline void TrajectoryPlanningService::set_trajtype(::IBUS::TrajectoryType value) {
  
  trajtype_ = value;
  // @@protoc_insertion_point(field_set:IBUS.TrajectoryPlanningService.TrajType)
}

// double TrajectoryLength = 3;
inline void TrajectoryPlanningService::clear_trajectorylength() {
  trajectorylength_ = 0;
}
inline double TrajectoryPlanningService::trajectorylength() const {
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPlanningService.TrajectoryLength)
  return trajectorylength_;
}
inline void TrajectoryPlanningService::set_trajectorylength(double value) {
  
  trajectorylength_ = value;
  // @@protoc_insertion_point(field_set:IBUS.TrajectoryPlanningService.TrajectoryLength)
}

// double TrajectoryTime = 4;
inline void TrajectoryPlanningService::clear_trajectorytime() {
  trajectorytime_ = 0;
}
inline double TrajectoryPlanningService::trajectorytime() const {
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPlanningService.TrajectoryTime)
  return trajectorytime_;
}
inline void TrajectoryPlanningService::set_trajectorytime(double value) {
  
  trajectorytime_ = value;
  // @@protoc_insertion_point(field_set:IBUS.TrajectoryPlanningService.TrajectoryTime)
}

// repeated .IBUS.TrajectoryPoint TrajectoryPoints = 5;
inline int TrajectoryPlanningService::trajectorypoints_size() const {
  return trajectorypoints_.size();
}
inline void TrajectoryPlanningService::clear_trajectorypoints() {
  trajectorypoints_.Clear();
}
inline ::IBUS::TrajectoryPoint* TrajectoryPlanningService::mutable_trajectorypoints(int index) {
  // @@protoc_insertion_point(field_mutable:IBUS.TrajectoryPlanningService.TrajectoryPoints)
  return trajectorypoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::TrajectoryPoint >*
TrajectoryPlanningService::mutable_trajectorypoints() {
  // @@protoc_insertion_point(field_mutable_list:IBUS.TrajectoryPlanningService.TrajectoryPoints)
  return &trajectorypoints_;
}
inline const ::IBUS::TrajectoryPoint& TrajectoryPlanningService::trajectorypoints(int index) const {
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPlanningService.TrajectoryPoints)
  return trajectorypoints_.Get(index);
}
inline ::IBUS::TrajectoryPoint* TrajectoryPlanningService::add_trajectorypoints() {
  // @@protoc_insertion_point(field_add:IBUS.TrajectoryPlanningService.TrajectoryPoints)
  return trajectorypoints_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::TrajectoryPoint >&
TrajectoryPlanningService::trajectorypoints() const {
  // @@protoc_insertion_point(field_list:IBUS.TrajectoryPlanningService.TrajectoryPoints)
  return trajectorypoints_;
}

// repeated double LatMaxOffset = 6;
inline int TrajectoryPlanningService::latmaxoffset_size() const {
  return latmaxoffset_.size();
}
inline void TrajectoryPlanningService::clear_latmaxoffset() {
  latmaxoffset_.Clear();
}
inline double TrajectoryPlanningService::latmaxoffset(int index) const {
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPlanningService.LatMaxOffset)
  return latmaxoffset_.Get(index);
}
inline void TrajectoryPlanningService::set_latmaxoffset(int index, double value) {
  latmaxoffset_.Set(index, value);
  // @@protoc_insertion_point(field_set:IBUS.TrajectoryPlanningService.LatMaxOffset)
}
inline void TrajectoryPlanningService::add_latmaxoffset(double value) {
  latmaxoffset_.Add(value);
  // @@protoc_insertion_point(field_add:IBUS.TrajectoryPlanningService.LatMaxOffset)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TrajectoryPlanningService::latmaxoffset() const {
  // @@protoc_insertion_point(field_list:IBUS.TrajectoryPlanningService.LatMaxOffset)
  return latmaxoffset_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TrajectoryPlanningService::mutable_latmaxoffset() {
  // @@protoc_insertion_point(field_mutable_list:IBUS.TrajectoryPlanningService.LatMaxOffset)
  return &latmaxoffset_;
}

// repeated .IBUS.RefLinePoint RefLine = 7;
inline int TrajectoryPlanningService::refline_size() const {
  return refline_.size();
}
inline void TrajectoryPlanningService::clear_refline() {
  refline_.Clear();
}
inline ::IBUS::RefLinePoint* TrajectoryPlanningService::mutable_refline(int index) {
  // @@protoc_insertion_point(field_mutable:IBUS.TrajectoryPlanningService.RefLine)
  return refline_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::RefLinePoint >*
TrajectoryPlanningService::mutable_refline() {
  // @@protoc_insertion_point(field_mutable_list:IBUS.TrajectoryPlanningService.RefLine)
  return &refline_;
}
inline const ::IBUS::RefLinePoint& TrajectoryPlanningService::refline(int index) const {
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPlanningService.RefLine)
  return refline_.Get(index);
}
inline ::IBUS::RefLinePoint* TrajectoryPlanningService::add_refline() {
  // @@protoc_insertion_point(field_add:IBUS.TrajectoryPlanningService.RefLine)
  return refline_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::RefLinePoint >&
TrajectoryPlanningService::refline() const {
  // @@protoc_insertion_point(field_list:IBUS.TrajectoryPlanningService.RefLine)
  return refline_;
}

// repeated .IBUS.PathBoundPoint PathBound = 8;
inline int TrajectoryPlanningService::pathbound_size() const {
  return pathbound_.size();
}
inline void TrajectoryPlanningService::clear_pathbound() {
  pathbound_.Clear();
}
inline ::IBUS::PathBoundPoint* TrajectoryPlanningService::mutable_pathbound(int index) {
  // @@protoc_insertion_point(field_mutable:IBUS.TrajectoryPlanningService.PathBound)
  return pathbound_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::PathBoundPoint >*
TrajectoryPlanningService::mutable_pathbound() {
  // @@protoc_insertion_point(field_mutable_list:IBUS.TrajectoryPlanningService.PathBound)
  return &pathbound_;
}
inline const ::IBUS::PathBoundPoint& TrajectoryPlanningService::pathbound(int index) const {
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPlanningService.PathBound)
  return pathbound_.Get(index);
}
inline ::IBUS::PathBoundPoint* TrajectoryPlanningService::add_pathbound() {
  // @@protoc_insertion_point(field_add:IBUS.TrajectoryPlanningService.PathBound)
  return pathbound_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IBUS::PathBoundPoint >&
TrajectoryPlanningService::pathbound() const {
  // @@protoc_insertion_point(field_list:IBUS.TrajectoryPlanningService.PathBound)
  return pathbound_;
}

// .IBUS.DebugPointInf DebugPoint = 9;
inline bool TrajectoryPlanningService::has_debugpoint() const {
  return this != internal_default_instance() && debugpoint_ != nullptr;
}
inline void TrajectoryPlanningService::clear_debugpoint() {
  if (GetArenaNoVirtual() == nullptr && debugpoint_ != nullptr) {
    delete debugpoint_;
  }
  debugpoint_ = nullptr;
}
inline const ::IBUS::DebugPointInf& TrajectoryPlanningService::debugpoint() const {
  const ::IBUS::DebugPointInf* p = debugpoint_;
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPlanningService.DebugPoint)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::DebugPointInf*>(
      &::IBUS::_DebugPointInf_default_instance_);
}
inline ::IBUS::DebugPointInf* TrajectoryPlanningService::release_debugpoint() {
  // @@protoc_insertion_point(field_release:IBUS.TrajectoryPlanningService.DebugPoint)
  
  ::IBUS::DebugPointInf* temp = debugpoint_;
  debugpoint_ = nullptr;
  return temp;
}
inline ::IBUS::DebugPointInf* TrajectoryPlanningService::mutable_debugpoint() {
  
  if (debugpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::DebugPointInf>(GetArenaNoVirtual());
    debugpoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.TrajectoryPlanningService.DebugPoint)
  return debugpoint_;
}
inline void TrajectoryPlanningService::set_allocated_debugpoint(::IBUS::DebugPointInf* debugpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete debugpoint_;
  }
  if (debugpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      debugpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, debugpoint, submessage_arena);
    }
    
  } else {
    
  }
  debugpoint_ = debugpoint;
  // @@protoc_insertion_point(field_set_allocated:IBUS.TrajectoryPlanningService.DebugPoint)
}

// .IBUS.ControlPointInf ControlPoint = 10;
inline bool TrajectoryPlanningService::has_controlpoint() const {
  return this != internal_default_instance() && controlpoint_ != nullptr;
}
inline void TrajectoryPlanningService::clear_controlpoint() {
  if (GetArenaNoVirtual() == nullptr && controlpoint_ != nullptr) {
    delete controlpoint_;
  }
  controlpoint_ = nullptr;
}
inline const ::IBUS::ControlPointInf& TrajectoryPlanningService::controlpoint() const {
  const ::IBUS::ControlPointInf* p = controlpoint_;
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPlanningService.ControlPoint)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::ControlPointInf*>(
      &::IBUS::_ControlPointInf_default_instance_);
}
inline ::IBUS::ControlPointInf* TrajectoryPlanningService::release_controlpoint() {
  // @@protoc_insertion_point(field_release:IBUS.TrajectoryPlanningService.ControlPoint)
  
  ::IBUS::ControlPointInf* temp = controlpoint_;
  controlpoint_ = nullptr;
  return temp;
}
inline ::IBUS::ControlPointInf* TrajectoryPlanningService::mutable_controlpoint() {
  
  if (controlpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::ControlPointInf>(GetArenaNoVirtual());
    controlpoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.TrajectoryPlanningService.ControlPoint)
  return controlpoint_;
}
inline void TrajectoryPlanningService::set_allocated_controlpoint(::IBUS::ControlPointInf* controlpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete controlpoint_;
  }
  if (controlpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      controlpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controlpoint, submessage_arena);
    }
    
  } else {
    
  }
  controlpoint_ = controlpoint;
  // @@protoc_insertion_point(field_set_allocated:IBUS.TrajectoryPlanningService.ControlPoint)
}

// uint32 TrajectoryPlanningServiceFlg = 11;
inline void TrajectoryPlanningService::clear_trajectoryplanningserviceflg() {
  trajectoryplanningserviceflg_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TrajectoryPlanningService::trajectoryplanningserviceflg() const {
  // @@protoc_insertion_point(field_get:IBUS.TrajectoryPlanningService.TrajectoryPlanningServiceFlg)
  return trajectoryplanningserviceflg_;
}
inline void TrajectoryPlanningService::set_trajectoryplanningserviceflg(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  trajectoryplanningserviceflg_ = value;
  // @@protoc_insertion_point(field_set:IBUS.TrajectoryPlanningService.TrajectoryPlanningServiceFlg)
}

// -------------------------------------------------------------------

// DecisionPlanMsg

// .IBUS.NavigationService NavigationInterface = 1;
inline bool DecisionPlanMsg::has_navigationinterface() const {
  return this != internal_default_instance() && navigationinterface_ != nullptr;
}
inline void DecisionPlanMsg::clear_navigationinterface() {
  if (GetArenaNoVirtual() == nullptr && navigationinterface_ != nullptr) {
    delete navigationinterface_;
  }
  navigationinterface_ = nullptr;
}
inline const ::IBUS::NavigationService& DecisionPlanMsg::navigationinterface() const {
  const ::IBUS::NavigationService* p = navigationinterface_;
  // @@protoc_insertion_point(field_get:IBUS.DecisionPlanMsg.NavigationInterface)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::NavigationService*>(
      &::IBUS::_NavigationService_default_instance_);
}
inline ::IBUS::NavigationService* DecisionPlanMsg::release_navigationinterface() {
  // @@protoc_insertion_point(field_release:IBUS.DecisionPlanMsg.NavigationInterface)
  
  ::IBUS::NavigationService* temp = navigationinterface_;
  navigationinterface_ = nullptr;
  return temp;
}
inline ::IBUS::NavigationService* DecisionPlanMsg::mutable_navigationinterface() {
  
  if (navigationinterface_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::NavigationService>(GetArenaNoVirtual());
    navigationinterface_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.DecisionPlanMsg.NavigationInterface)
  return navigationinterface_;
}
inline void DecisionPlanMsg::set_allocated_navigationinterface(::IBUS::NavigationService* navigationinterface) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete navigationinterface_;
  }
  if (navigationinterface) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      navigationinterface = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, navigationinterface, submessage_arena);
    }
    
  } else {
    
  }
  navigationinterface_ = navigationinterface;
  // @@protoc_insertion_point(field_set_allocated:IBUS.DecisionPlanMsg.NavigationInterface)
}

// .IBUS.DecisionService DecisionInterface = 2;
inline bool DecisionPlanMsg::has_decisioninterface() const {
  return this != internal_default_instance() && decisioninterface_ != nullptr;
}
inline void DecisionPlanMsg::clear_decisioninterface() {
  if (GetArenaNoVirtual() == nullptr && decisioninterface_ != nullptr) {
    delete decisioninterface_;
  }
  decisioninterface_ = nullptr;
}
inline const ::IBUS::DecisionService& DecisionPlanMsg::decisioninterface() const {
  const ::IBUS::DecisionService* p = decisioninterface_;
  // @@protoc_insertion_point(field_get:IBUS.DecisionPlanMsg.DecisionInterface)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::DecisionService*>(
      &::IBUS::_DecisionService_default_instance_);
}
inline ::IBUS::DecisionService* DecisionPlanMsg::release_decisioninterface() {
  // @@protoc_insertion_point(field_release:IBUS.DecisionPlanMsg.DecisionInterface)
  
  ::IBUS::DecisionService* temp = decisioninterface_;
  decisioninterface_ = nullptr;
  return temp;
}
inline ::IBUS::DecisionService* DecisionPlanMsg::mutable_decisioninterface() {
  
  if (decisioninterface_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::DecisionService>(GetArenaNoVirtual());
    decisioninterface_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.DecisionPlanMsg.DecisionInterface)
  return decisioninterface_;
}
inline void DecisionPlanMsg::set_allocated_decisioninterface(::IBUS::DecisionService* decisioninterface) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete decisioninterface_;
  }
  if (decisioninterface) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      decisioninterface = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, decisioninterface, submessage_arena);
    }
    
  } else {
    
  }
  decisioninterface_ = decisioninterface;
  // @@protoc_insertion_point(field_set_allocated:IBUS.DecisionPlanMsg.DecisionInterface)
}

// .IBUS.TrajectoryPlanningService TrajectoryPlanningInterface = 3;
inline bool DecisionPlanMsg::has_trajectoryplanninginterface() const {
  return this != internal_default_instance() && trajectoryplanninginterface_ != nullptr;
}
inline void DecisionPlanMsg::clear_trajectoryplanninginterface() {
  if (GetArenaNoVirtual() == nullptr && trajectoryplanninginterface_ != nullptr) {
    delete trajectoryplanninginterface_;
  }
  trajectoryplanninginterface_ = nullptr;
}
inline const ::IBUS::TrajectoryPlanningService& DecisionPlanMsg::trajectoryplanninginterface() const {
  const ::IBUS::TrajectoryPlanningService* p = trajectoryplanninginterface_;
  // @@protoc_insertion_point(field_get:IBUS.DecisionPlanMsg.TrajectoryPlanningInterface)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::TrajectoryPlanningService*>(
      &::IBUS::_TrajectoryPlanningService_default_instance_);
}
inline ::IBUS::TrajectoryPlanningService* DecisionPlanMsg::release_trajectoryplanninginterface() {
  // @@protoc_insertion_point(field_release:IBUS.DecisionPlanMsg.TrajectoryPlanningInterface)
  
  ::IBUS::TrajectoryPlanningService* temp = trajectoryplanninginterface_;
  trajectoryplanninginterface_ = nullptr;
  return temp;
}
inline ::IBUS::TrajectoryPlanningService* DecisionPlanMsg::mutable_trajectoryplanninginterface() {
  
  if (trajectoryplanninginterface_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::TrajectoryPlanningService>(GetArenaNoVirtual());
    trajectoryplanninginterface_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.DecisionPlanMsg.TrajectoryPlanningInterface)
  return trajectoryplanninginterface_;
}
inline void DecisionPlanMsg::set_allocated_trajectoryplanninginterface(::IBUS::TrajectoryPlanningService* trajectoryplanninginterface) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete trajectoryplanninginterface_;
  }
  if (trajectoryplanninginterface) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      trajectoryplanninginterface = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trajectoryplanninginterface, submessage_arena);
    }
    
  } else {
    
  }
  trajectoryplanninginterface_ = trajectoryplanninginterface;
  // @@protoc_insertion_point(field_set_allocated:IBUS.DecisionPlanMsg.TrajectoryPlanningInterface)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace IBUS

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::IBUS::MissionDecision_MissionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IBUS::MissionDecision_MissionType>() {
  return ::IBUS::MissionDecision_MissionType_descriptor();
}
template <> struct is_proto_enum< ::IBUS::MissionDecision_StatusMDecision> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IBUS::MissionDecision_StatusMDecision>() {
  return ::IBUS::MissionDecision_StatusMDecision_descriptor();
}
template <> struct is_proto_enum< ::IBUS::DDTDecision_ObjectDecision_type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IBUS::DDTDecision_ObjectDecision_type>() {
  return ::IBUS::DDTDecision_ObjectDecision_type_descriptor();
}
template <> struct is_proto_enum< ::IBUS::DDTDecision_ObjectDecision_DDTState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IBUS::DDTDecision_ObjectDecision_DDTState>() {
  return ::IBUS::DDTDecision_ObjectDecision_DDTState_descriptor();
}
template <> struct is_proto_enum< ::IBUS::TrajectoryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IBUS::TrajectoryType>() {
  return ::IBUS::TrajectoryType_descriptor();
}
template <> struct is_proto_enum< ::IBUS::DebugPointType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IBUS::DebugPointType>() {
  return ::IBUS::DebugPointType_descriptor();
}
template <> struct is_proto_enum< ::IBUS::GearType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IBUS::GearType>() {
  return ::IBUS::GearType_descriptor();
}
template <> struct is_proto_enum< ::IBUS::ThrottleFlagType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IBUS::ThrottleFlagType>() {
  return ::IBUS::ThrottleFlagType_descriptor();
}
template <> struct is_proto_enum< ::IBUS::BrakeFlagType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IBUS::BrakeFlagType>() {
  return ::IBUS::BrakeFlagType_descriptor();
}
template <> struct is_proto_enum< ::IBUS::EpbType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IBUS::EpbType>() {
  return ::IBUS::EpbType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_DecisonInterface_2eproto
