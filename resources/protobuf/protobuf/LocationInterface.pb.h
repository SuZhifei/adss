// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LocationInterface.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_LocationInterface_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_LocationInterface_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_LocationInterface_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_LocationInterface_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[3]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_LocationInterface_2eproto;
namespace IBUS {
class Bias;
class BiasDefaultTypeInternal;
extern BiasDefaultTypeInternal _Bias_default_instance_;
class LocationService;
class LocationServiceDefaultTypeInternal;
extern LocationServiceDefaultTypeInternal _LocationService_default_instance_;
class RPY;
class RPYDefaultTypeInternal;
extern RPYDefaultTypeInternal _RPY_default_instance_;
}  // namespace IBUS
PROTOBUF_NAMESPACE_OPEN
template<> ::IBUS::Bias* Arena::CreateMaybeMessage<::IBUS::Bias>(Arena*);
template<> ::IBUS::LocationService* Arena::CreateMaybeMessage<::IBUS::LocationService>(Arena*);
template<> ::IBUS::RPY* Arena::CreateMaybeMessage<::IBUS::RPY>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace IBUS {

enum LocationService_pStatus : int {
  LocationService_pStatus_GOOD = 0,
  LocationService_pStatus_POSITION_NOT_GOOD = 1,
  LocationService_pStatus_ORIENTATIONNOTGOOD = 2,
  LocationService_pStatus_LocationService_pStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LocationService_pStatus_LocationService_pStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LocationService_pStatus_IsValid(int value);
constexpr LocationService_pStatus LocationService_pStatus_pStatus_MIN = LocationService_pStatus_GOOD;
constexpr LocationService_pStatus LocationService_pStatus_pStatus_MAX = LocationService_pStatus_ORIENTATIONNOTGOOD;
constexpr int LocationService_pStatus_pStatus_ARRAYSIZE = LocationService_pStatus_pStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LocationService_pStatus_descriptor();
template<typename T>
inline const std::string& LocationService_pStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LocationService_pStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LocationService_pStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LocationService_pStatus_descriptor(), enum_t_value);
}
inline bool LocationService_pStatus_Parse(
    const std::string& name, LocationService_pStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LocationService_pStatus>(
    LocationService_pStatus_descriptor(), name, value);
}
// ===================================================================

class RPY :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IBUS.RPY) */ {
 public:
  RPY();
  virtual ~RPY();

  RPY(const RPY& from);
  RPY(RPY&& from) noexcept
    : RPY() {
    *this = ::std::move(from);
  }

  inline RPY& operator=(const RPY& from) {
    CopyFrom(from);
    return *this;
  }
  inline RPY& operator=(RPY&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RPY& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RPY* internal_default_instance() {
    return reinterpret_cast<const RPY*>(
               &_RPY_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RPY& a, RPY& b) {
    a.Swap(&b);
  }
  inline void Swap(RPY* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RPY* New() const final {
    return CreateMaybeMessage<RPY>(nullptr);
  }

  RPY* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RPY>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RPY& from);
  void MergeFrom(const RPY& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RPY* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IBUS.RPY";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_LocationInterface_2eproto);
    return ::descriptor_table_LocationInterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYawFieldNumber = 11,
    kPitchFieldNumber = 9,
    kRollFieldNumber = 10,
  };
  // float yaw = 11;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);

  // float pitch = 9;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);

  // float roll = 10;
  void clear_roll();
  float roll() const;
  void set_roll(float value);

  // @@protoc_insertion_point(class_scope:IBUS.RPY)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float yaw_;
  float pitch_;
  float roll_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_LocationInterface_2eproto;
};
// -------------------------------------------------------------------

class Bias :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IBUS.Bias) */ {
 public:
  Bias();
  virtual ~Bias();

  Bias(const Bias& from);
  Bias(Bias&& from) noexcept
    : Bias() {
    *this = ::std::move(from);
  }

  inline Bias& operator=(const Bias& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bias& operator=(Bias&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Bias& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Bias* internal_default_instance() {
    return reinterpret_cast<const Bias*>(
               &_Bias_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Bias& a, Bias& b) {
    a.Swap(&b);
  }
  inline void Swap(Bias* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Bias* New() const final {
    return CreateMaybeMessage<Bias>(nullptr);
  }

  Bias* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Bias>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Bias& from);
  void MergeFrom(const Bias& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bias* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IBUS.Bias";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_LocationInterface_2eproto);
    return ::descriptor_table_LocationInterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCovarianceFieldNumber = 3,
    kLinearAccelerationBiasFieldNumber = 1,
    kAngularVelocityBiasFieldNumber = 2,
  };
  // repeated double Covariance = 3;
  int covariance_size() const;
  void clear_covariance();
  double covariance(int index) const;
  void set_covariance(int index, double value);
  void add_covariance(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      covariance() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_covariance();

  // .IBUS.Point3D LinearAccelerationBias = 1;
  bool has_linearaccelerationbias() const;
  void clear_linearaccelerationbias();
  const ::IBUS::Point3D& linearaccelerationbias() const;
  ::IBUS::Point3D* release_linearaccelerationbias();
  ::IBUS::Point3D* mutable_linearaccelerationbias();
  void set_allocated_linearaccelerationbias(::IBUS::Point3D* linearaccelerationbias);

  // .IBUS.Point3D AngularVelocityBias = 2;
  bool has_angularvelocitybias() const;
  void clear_angularvelocitybias();
  const ::IBUS::Point3D& angularvelocitybias() const;
  ::IBUS::Point3D* release_angularvelocitybias();
  ::IBUS::Point3D* mutable_angularvelocitybias();
  void set_allocated_angularvelocitybias(::IBUS::Point3D* angularvelocitybias);

  // @@protoc_insertion_point(class_scope:IBUS.Bias)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > covariance_;
  mutable std::atomic<int> _covariance_cached_byte_size_;
  ::IBUS::Point3D* linearaccelerationbias_;
  ::IBUS::Point3D* angularvelocitybias_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_LocationInterface_2eproto;
};
// -------------------------------------------------------------------

class LocationService :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IBUS.LocationService) */ {
 public:
  LocationService();
  virtual ~LocationService();

  LocationService(const LocationService& from);
  LocationService(LocationService&& from) noexcept
    : LocationService() {
    *this = ::std::move(from);
  }

  inline LocationService& operator=(const LocationService& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationService& operator=(LocationService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LocationService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocationService* internal_default_instance() {
    return reinterpret_cast<const LocationService*>(
               &_LocationService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LocationService& a, LocationService& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationService* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LocationService* New() const final {
    return CreateMaybeMessage<LocationService>(nullptr);
  }

  LocationService* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LocationService>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LocationService& from);
  void MergeFrom(const LocationService& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationService* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IBUS.LocationService";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_LocationInterface_2eproto);
    return ::descriptor_table_LocationInterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef LocationService_pStatus pStatus;
  static constexpr pStatus GOOD =
    LocationService_pStatus_GOOD;
  static constexpr pStatus POSITION_NOT_GOOD =
    LocationService_pStatus_POSITION_NOT_GOOD;
  static constexpr pStatus ORIENTATIONNOTGOOD =
    LocationService_pStatus_ORIENTATIONNOTGOOD;
  static inline bool pStatus_IsValid(int value) {
    return LocationService_pStatus_IsValid(value);
  }
  static constexpr pStatus pStatus_MIN =
    LocationService_pStatus_pStatus_MIN;
  static constexpr pStatus pStatus_MAX =
    LocationService_pStatus_pStatus_MAX;
  static constexpr int pStatus_ARRAYSIZE =
    LocationService_pStatus_pStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  pStatus_descriptor() {
    return LocationService_pStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& pStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, pStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function pStatus_Name.");
    return LocationService_pStatus_Name(enum_t_value);
  }
  static inline bool pStatus_Parse(const std::string& name,
      pStatus* value) {
    return LocationService_pStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRefPointFieldNumber = 9,
    kPoseFieldNumber = 10,
    kVelFieldNumber = 11,
    kAccFieldNumber = 12,
    kImubFieldNumber = 13,
    kRpyFieldNumber = 14,
    kParentCoordinateFieldNumber = 2,
    kChildCoordinateFieldNumber = 3,
    kPositionStatusFieldNumber = 4,
    kUTMZoneIDFieldNumber = 5,
    kIsSouthFieldNumber = 6,
    kOffsetXFieldNumber = 7,
    kOffsetYFieldNumber = 8,
  };
  // .IBUS.Header header = 1;
  bool has_header() const;
  void clear_header();
  const ::IBUS::Header& header() const;
  ::IBUS::Header* release_header();
  ::IBUS::Header* mutable_header();
  void set_allocated_header(::IBUS::Header* header);

  // .IBUS.Point3D RefPoint = 9;
  bool has_refpoint() const;
  void clear_refpoint();
  const ::IBUS::Point3D& refpoint() const;
  ::IBUS::Point3D* release_refpoint();
  ::IBUS::Point3D* mutable_refpoint();
  void set_allocated_refpoint(::IBUS::Point3D* refpoint);

  // .IBUS.Pose pose = 10;
  bool has_pose() const;
  void clear_pose();
  const ::IBUS::Pose& pose() const;
  ::IBUS::Pose* release_pose();
  ::IBUS::Pose* mutable_pose();
  void set_allocated_pose(::IBUS::Pose* pose);

  // .IBUS.Velocity Vel = 11;
  bool has_vel() const;
  void clear_vel();
  const ::IBUS::Velocity& vel() const;
  ::IBUS::Velocity* release_vel();
  ::IBUS::Velocity* mutable_vel();
  void set_allocated_vel(::IBUS::Velocity* vel);

  // .IBUS.Acceleration acc = 12;
  bool has_acc() const;
  void clear_acc();
  const ::IBUS::Acceleration& acc() const;
  ::IBUS::Acceleration* release_acc();
  ::IBUS::Acceleration* mutable_acc();
  void set_allocated_acc(::IBUS::Acceleration* acc);

  // .IBUS.Bias imub = 13;
  bool has_imub() const;
  void clear_imub();
  const ::IBUS::Bias& imub() const;
  ::IBUS::Bias* release_imub();
  ::IBUS::Bias* mutable_imub();
  void set_allocated_imub(::IBUS::Bias* imub);

  // .IBUS.RPY rpy = 14;
  bool has_rpy() const;
  void clear_rpy();
  const ::IBUS::RPY& rpy() const;
  ::IBUS::RPY* release_rpy();
  ::IBUS::RPY* mutable_rpy();
  void set_allocated_rpy(::IBUS::RPY* rpy);

  // .IBUS.FRAMETYPE ParentCoordinate = 2;
  void clear_parentcoordinate();
  ::IBUS::FRAMETYPE parentcoordinate() const;
  void set_parentcoordinate(::IBUS::FRAMETYPE value);

  // .IBUS.FRAMETYPE ChildCoordinate = 3;
  void clear_childcoordinate();
  ::IBUS::FRAMETYPE childcoordinate() const;
  void set_childcoordinate(::IBUS::FRAMETYPE value);

  // .IBUS.LocationService.pStatus PositionStatus = 4;
  void clear_positionstatus();
  ::IBUS::LocationService_pStatus positionstatus() const;
  void set_positionstatus(::IBUS::LocationService_pStatus value);

  // uint32 UTMZoneID = 5;
  void clear_utmzoneid();
  ::PROTOBUF_NAMESPACE_ID::uint32 utmzoneid() const;
  void set_utmzoneid(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // bool IsSouth = 6;
  void clear_issouth();
  bool issouth() const;
  void set_issouth(bool value);

  // uint32 OffsetX = 7;
  void clear_offsetx();
  ::PROTOBUF_NAMESPACE_ID::uint32 offsetx() const;
  void set_offsetx(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 OffsetY = 8;
  void clear_offsety();
  ::PROTOBUF_NAMESPACE_ID::uint32 offsety() const;
  void set_offsety(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:IBUS.LocationService)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::IBUS::Header* header_;
  ::IBUS::Point3D* refpoint_;
  ::IBUS::Pose* pose_;
  ::IBUS::Velocity* vel_;
  ::IBUS::Acceleration* acc_;
  ::IBUS::Bias* imub_;
  ::IBUS::RPY* rpy_;
  int parentcoordinate_;
  int childcoordinate_;
  int positionstatus_;
  ::PROTOBUF_NAMESPACE_ID::uint32 utmzoneid_;
  bool issouth_;
  ::PROTOBUF_NAMESPACE_ID::uint32 offsetx_;
  ::PROTOBUF_NAMESPACE_ID::uint32 offsety_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_LocationInterface_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RPY

// float pitch = 9;
inline void RPY::clear_pitch() {
  pitch_ = 0;
}
inline float RPY::pitch() const {
  // @@protoc_insertion_point(field_get:IBUS.RPY.pitch)
  return pitch_;
}
inline void RPY::set_pitch(float value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:IBUS.RPY.pitch)
}

// float roll = 10;
inline void RPY::clear_roll() {
  roll_ = 0;
}
inline float RPY::roll() const {
  // @@protoc_insertion_point(field_get:IBUS.RPY.roll)
  return roll_;
}
inline void RPY::set_roll(float value) {
  
  roll_ = value;
  // @@protoc_insertion_point(field_set:IBUS.RPY.roll)
}

// float yaw = 11;
inline void RPY::clear_yaw() {
  yaw_ = 0;
}
inline float RPY::yaw() const {
  // @@protoc_insertion_point(field_get:IBUS.RPY.yaw)
  return yaw_;
}
inline void RPY::set_yaw(float value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:IBUS.RPY.yaw)
}

// -------------------------------------------------------------------

// Bias

// .IBUS.Point3D LinearAccelerationBias = 1;
inline bool Bias::has_linearaccelerationbias() const {
  return this != internal_default_instance() && linearaccelerationbias_ != nullptr;
}
inline const ::IBUS::Point3D& Bias::linearaccelerationbias() const {
  const ::IBUS::Point3D* p = linearaccelerationbias_;
  // @@protoc_insertion_point(field_get:IBUS.Bias.LinearAccelerationBias)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::Point3D*>(
      &::IBUS::_Point3D_default_instance_);
}
inline ::IBUS::Point3D* Bias::release_linearaccelerationbias() {
  // @@protoc_insertion_point(field_release:IBUS.Bias.LinearAccelerationBias)
  
  ::IBUS::Point3D* temp = linearaccelerationbias_;
  linearaccelerationbias_ = nullptr;
  return temp;
}
inline ::IBUS::Point3D* Bias::mutable_linearaccelerationbias() {
  
  if (linearaccelerationbias_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::Point3D>(GetArenaNoVirtual());
    linearaccelerationbias_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.Bias.LinearAccelerationBias)
  return linearaccelerationbias_;
}
inline void Bias::set_allocated_linearaccelerationbias(::IBUS::Point3D* linearaccelerationbias) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(linearaccelerationbias_);
  }
  if (linearaccelerationbias) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      linearaccelerationbias = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linearaccelerationbias, submessage_arena);
    }
    
  } else {
    
  }
  linearaccelerationbias_ = linearaccelerationbias;
  // @@protoc_insertion_point(field_set_allocated:IBUS.Bias.LinearAccelerationBias)
}

// .IBUS.Point3D AngularVelocityBias = 2;
inline bool Bias::has_angularvelocitybias() const {
  return this != internal_default_instance() && angularvelocitybias_ != nullptr;
}
inline const ::IBUS::Point3D& Bias::angularvelocitybias() const {
  const ::IBUS::Point3D* p = angularvelocitybias_;
  // @@protoc_insertion_point(field_get:IBUS.Bias.AngularVelocityBias)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::Point3D*>(
      &::IBUS::_Point3D_default_instance_);
}
inline ::IBUS::Point3D* Bias::release_angularvelocitybias() {
  // @@protoc_insertion_point(field_release:IBUS.Bias.AngularVelocityBias)
  
  ::IBUS::Point3D* temp = angularvelocitybias_;
  angularvelocitybias_ = nullptr;
  return temp;
}
inline ::IBUS::Point3D* Bias::mutable_angularvelocitybias() {
  
  if (angularvelocitybias_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::Point3D>(GetArenaNoVirtual());
    angularvelocitybias_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.Bias.AngularVelocityBias)
  return angularvelocitybias_;
}
inline void Bias::set_allocated_angularvelocitybias(::IBUS::Point3D* angularvelocitybias) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(angularvelocitybias_);
  }
  if (angularvelocitybias) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      angularvelocitybias = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angularvelocitybias, submessage_arena);
    }
    
  } else {
    
  }
  angularvelocitybias_ = angularvelocitybias;
  // @@protoc_insertion_point(field_set_allocated:IBUS.Bias.AngularVelocityBias)
}

// repeated double Covariance = 3;
inline int Bias::covariance_size() const {
  return covariance_.size();
}
inline void Bias::clear_covariance() {
  covariance_.Clear();
}
inline double Bias::covariance(int index) const {
  // @@protoc_insertion_point(field_get:IBUS.Bias.Covariance)
  return covariance_.Get(index);
}
inline void Bias::set_covariance(int index, double value) {
  covariance_.Set(index, value);
  // @@protoc_insertion_point(field_set:IBUS.Bias.Covariance)
}
inline void Bias::add_covariance(double value) {
  covariance_.Add(value);
  // @@protoc_insertion_point(field_add:IBUS.Bias.Covariance)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Bias::covariance() const {
  // @@protoc_insertion_point(field_list:IBUS.Bias.Covariance)
  return covariance_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Bias::mutable_covariance() {
  // @@protoc_insertion_point(field_mutable_list:IBUS.Bias.Covariance)
  return &covariance_;
}

// -------------------------------------------------------------------

// LocationService

// .IBUS.Header header = 1;
inline bool LocationService::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline const ::IBUS::Header& LocationService::header() const {
  const ::IBUS::Header* p = header_;
  // @@protoc_insertion_point(field_get:IBUS.LocationService.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::Header*>(
      &::IBUS::_Header_default_instance_);
}
inline ::IBUS::Header* LocationService::release_header() {
  // @@protoc_insertion_point(field_release:IBUS.LocationService.header)
  
  ::IBUS::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::IBUS::Header* LocationService::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.LocationService.header)
  return header_;
}
inline void LocationService::set_allocated_header(::IBUS::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:IBUS.LocationService.header)
}

// .IBUS.FRAMETYPE ParentCoordinate = 2;
inline void LocationService::clear_parentcoordinate() {
  parentcoordinate_ = 0;
}
inline ::IBUS::FRAMETYPE LocationService::parentcoordinate() const {
  // @@protoc_insertion_point(field_get:IBUS.LocationService.ParentCoordinate)
  return static_cast< ::IBUS::FRAMETYPE >(parentcoordinate_);
}
inline void LocationService::set_parentcoordinate(::IBUS::FRAMETYPE value) {
  
  parentcoordinate_ = value;
  // @@protoc_insertion_point(field_set:IBUS.LocationService.ParentCoordinate)
}

// .IBUS.FRAMETYPE ChildCoordinate = 3;
inline void LocationService::clear_childcoordinate() {
  childcoordinate_ = 0;
}
inline ::IBUS::FRAMETYPE LocationService::childcoordinate() const {
  // @@protoc_insertion_point(field_get:IBUS.LocationService.ChildCoordinate)
  return static_cast< ::IBUS::FRAMETYPE >(childcoordinate_);
}
inline void LocationService::set_childcoordinate(::IBUS::FRAMETYPE value) {
  
  childcoordinate_ = value;
  // @@protoc_insertion_point(field_set:IBUS.LocationService.ChildCoordinate)
}

// .IBUS.LocationService.pStatus PositionStatus = 4;
inline void LocationService::clear_positionstatus() {
  positionstatus_ = 0;
}
inline ::IBUS::LocationService_pStatus LocationService::positionstatus() const {
  // @@protoc_insertion_point(field_get:IBUS.LocationService.PositionStatus)
  return static_cast< ::IBUS::LocationService_pStatus >(positionstatus_);
}
inline void LocationService::set_positionstatus(::IBUS::LocationService_pStatus value) {
  
  positionstatus_ = value;
  // @@protoc_insertion_point(field_set:IBUS.LocationService.PositionStatus)
}

// uint32 UTMZoneID = 5;
inline void LocationService::clear_utmzoneid() {
  utmzoneid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LocationService::utmzoneid() const {
  // @@protoc_insertion_point(field_get:IBUS.LocationService.UTMZoneID)
  return utmzoneid_;
}
inline void LocationService::set_utmzoneid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  utmzoneid_ = value;
  // @@protoc_insertion_point(field_set:IBUS.LocationService.UTMZoneID)
}

// bool IsSouth = 6;
inline void LocationService::clear_issouth() {
  issouth_ = false;
}
inline bool LocationService::issouth() const {
  // @@protoc_insertion_point(field_get:IBUS.LocationService.IsSouth)
  return issouth_;
}
inline void LocationService::set_issouth(bool value) {
  
  issouth_ = value;
  // @@protoc_insertion_point(field_set:IBUS.LocationService.IsSouth)
}

// uint32 OffsetX = 7;
inline void LocationService::clear_offsetx() {
  offsetx_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LocationService::offsetx() const {
  // @@protoc_insertion_point(field_get:IBUS.LocationService.OffsetX)
  return offsetx_;
}
inline void LocationService::set_offsetx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  offsetx_ = value;
  // @@protoc_insertion_point(field_set:IBUS.LocationService.OffsetX)
}

// uint32 OffsetY = 8;
inline void LocationService::clear_offsety() {
  offsety_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LocationService::offsety() const {
  // @@protoc_insertion_point(field_get:IBUS.LocationService.OffsetY)
  return offsety_;
}
inline void LocationService::set_offsety(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  offsety_ = value;
  // @@protoc_insertion_point(field_set:IBUS.LocationService.OffsetY)
}

// .IBUS.Point3D RefPoint = 9;
inline bool LocationService::has_refpoint() const {
  return this != internal_default_instance() && refpoint_ != nullptr;
}
inline const ::IBUS::Point3D& LocationService::refpoint() const {
  const ::IBUS::Point3D* p = refpoint_;
  // @@protoc_insertion_point(field_get:IBUS.LocationService.RefPoint)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::Point3D*>(
      &::IBUS::_Point3D_default_instance_);
}
inline ::IBUS::Point3D* LocationService::release_refpoint() {
  // @@protoc_insertion_point(field_release:IBUS.LocationService.RefPoint)
  
  ::IBUS::Point3D* temp = refpoint_;
  refpoint_ = nullptr;
  return temp;
}
inline ::IBUS::Point3D* LocationService::mutable_refpoint() {
  
  if (refpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::Point3D>(GetArenaNoVirtual());
    refpoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.LocationService.RefPoint)
  return refpoint_;
}
inline void LocationService::set_allocated_refpoint(::IBUS::Point3D* refpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(refpoint_);
  }
  if (refpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      refpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, refpoint, submessage_arena);
    }
    
  } else {
    
  }
  refpoint_ = refpoint;
  // @@protoc_insertion_point(field_set_allocated:IBUS.LocationService.RefPoint)
}

// .IBUS.Pose pose = 10;
inline bool LocationService::has_pose() const {
  return this != internal_default_instance() && pose_ != nullptr;
}
inline const ::IBUS::Pose& LocationService::pose() const {
  const ::IBUS::Pose* p = pose_;
  // @@protoc_insertion_point(field_get:IBUS.LocationService.pose)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::Pose*>(
      &::IBUS::_Pose_default_instance_);
}
inline ::IBUS::Pose* LocationService::release_pose() {
  // @@protoc_insertion_point(field_release:IBUS.LocationService.pose)
  
  ::IBUS::Pose* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::IBUS::Pose* LocationService::mutable_pose() {
  
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::Pose>(GetArenaNoVirtual());
    pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.LocationService.pose)
  return pose_;
}
inline void LocationService::set_allocated_pose(::IBUS::Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:IBUS.LocationService.pose)
}

// .IBUS.Velocity Vel = 11;
inline bool LocationService::has_vel() const {
  return this != internal_default_instance() && vel_ != nullptr;
}
inline const ::IBUS::Velocity& LocationService::vel() const {
  const ::IBUS::Velocity* p = vel_;
  // @@protoc_insertion_point(field_get:IBUS.LocationService.Vel)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::Velocity*>(
      &::IBUS::_Velocity_default_instance_);
}
inline ::IBUS::Velocity* LocationService::release_vel() {
  // @@protoc_insertion_point(field_release:IBUS.LocationService.Vel)
  
  ::IBUS::Velocity* temp = vel_;
  vel_ = nullptr;
  return temp;
}
inline ::IBUS::Velocity* LocationService::mutable_vel() {
  
  if (vel_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::Velocity>(GetArenaNoVirtual());
    vel_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.LocationService.Vel)
  return vel_;
}
inline void LocationService::set_allocated_vel(::IBUS::Velocity* vel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(vel_);
  }
  if (vel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      vel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vel, submessage_arena);
    }
    
  } else {
    
  }
  vel_ = vel;
  // @@protoc_insertion_point(field_set_allocated:IBUS.LocationService.Vel)
}

// .IBUS.Acceleration acc = 12;
inline bool LocationService::has_acc() const {
  return this != internal_default_instance() && acc_ != nullptr;
}
inline const ::IBUS::Acceleration& LocationService::acc() const {
  const ::IBUS::Acceleration* p = acc_;
  // @@protoc_insertion_point(field_get:IBUS.LocationService.acc)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::Acceleration*>(
      &::IBUS::_Acceleration_default_instance_);
}
inline ::IBUS::Acceleration* LocationService::release_acc() {
  // @@protoc_insertion_point(field_release:IBUS.LocationService.acc)
  
  ::IBUS::Acceleration* temp = acc_;
  acc_ = nullptr;
  return temp;
}
inline ::IBUS::Acceleration* LocationService::mutable_acc() {
  
  if (acc_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::Acceleration>(GetArenaNoVirtual());
    acc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.LocationService.acc)
  return acc_;
}
inline void LocationService::set_allocated_acc(::IBUS::Acceleration* acc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(acc_);
  }
  if (acc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      acc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acc, submessage_arena);
    }
    
  } else {
    
  }
  acc_ = acc;
  // @@protoc_insertion_point(field_set_allocated:IBUS.LocationService.acc)
}

// .IBUS.Bias imub = 13;
inline bool LocationService::has_imub() const {
  return this != internal_default_instance() && imub_ != nullptr;
}
inline void LocationService::clear_imub() {
  if (GetArenaNoVirtual() == nullptr && imub_ != nullptr) {
    delete imub_;
  }
  imub_ = nullptr;
}
inline const ::IBUS::Bias& LocationService::imub() const {
  const ::IBUS::Bias* p = imub_;
  // @@protoc_insertion_point(field_get:IBUS.LocationService.imub)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::Bias*>(
      &::IBUS::_Bias_default_instance_);
}
inline ::IBUS::Bias* LocationService::release_imub() {
  // @@protoc_insertion_point(field_release:IBUS.LocationService.imub)
  
  ::IBUS::Bias* temp = imub_;
  imub_ = nullptr;
  return temp;
}
inline ::IBUS::Bias* LocationService::mutable_imub() {
  
  if (imub_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::Bias>(GetArenaNoVirtual());
    imub_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.LocationService.imub)
  return imub_;
}
inline void LocationService::set_allocated_imub(::IBUS::Bias* imub) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete imub_;
  }
  if (imub) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      imub = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imub, submessage_arena);
    }
    
  } else {
    
  }
  imub_ = imub;
  // @@protoc_insertion_point(field_set_allocated:IBUS.LocationService.imub)
}

// .IBUS.RPY rpy = 14;
inline bool LocationService::has_rpy() const {
  return this != internal_default_instance() && rpy_ != nullptr;
}
inline void LocationService::clear_rpy() {
  if (GetArenaNoVirtual() == nullptr && rpy_ != nullptr) {
    delete rpy_;
  }
  rpy_ = nullptr;
}
inline const ::IBUS::RPY& LocationService::rpy() const {
  const ::IBUS::RPY* p = rpy_;
  // @@protoc_insertion_point(field_get:IBUS.LocationService.rpy)
  return p != nullptr ? *p : *reinterpret_cast<const ::IBUS::RPY*>(
      &::IBUS::_RPY_default_instance_);
}
inline ::IBUS::RPY* LocationService::release_rpy() {
  // @@protoc_insertion_point(field_release:IBUS.LocationService.rpy)
  
  ::IBUS::RPY* temp = rpy_;
  rpy_ = nullptr;
  return temp;
}
inline ::IBUS::RPY* LocationService::mutable_rpy() {
  
  if (rpy_ == nullptr) {
    auto* p = CreateMaybeMessage<::IBUS::RPY>(GetArenaNoVirtual());
    rpy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IBUS.LocationService.rpy)
  return rpy_;
}
inline void LocationService::set_allocated_rpy(::IBUS::RPY* rpy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rpy_;
  }
  if (rpy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rpy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rpy, submessage_arena);
    }
    
  } else {
    
  }
  rpy_ = rpy;
  // @@protoc_insertion_point(field_set_allocated:IBUS.LocationService.rpy)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace IBUS

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::IBUS::LocationService_pStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IBUS::LocationService_pStatus>() {
  return ::IBUS::LocationService_pStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_LocationInterface_2eproto
